package Basic.Tips;
// 用普通的方法求斐波那契数列第N项的时间复杂度为:O(N). 利用线性代数的加速可以降低为：O(logN)

// 用F[i]表示斐波那契数列的第i项。 斐波那契数列有如下规律：
// [F[3],F[2]] = [F[2],F[1]] * [a,b            [F[4],F[3]] = [F[3],F[2]] * [a,b
//                              c,d]                                        c,d]
//
// 这个2*2的矩阵可以推算的值为：a=1,b=1,c=1,d=0.  让X表示这个2行2列的矩阵，那么：
// 所以 [F[n],F[n-1]] = [F[2],F[1]] * X的n-2次方，因为F[2]=F[1]=1
// 所以 [F[n],F[n-1]] = [1,1] * X的n-2次方.  假设 X^(n-2) == T
// 所以 F[n] = T[0][0] + T[1][0]
// 现在的问题就是如何快速求出一个矩阵的次幂？   这和求一个标量的次幂是一个道理
// 比如10的75次方。 75 = 64 + 8 + 2 + 1  另t=10^1 不停地让t乘自己，就能得到：10^1, 10^2, 10^4, 10^8, 10^16, 10^32,
// 10^64, 只需要把需要的累加起来就行了。这样能达到logN的速度。用二进制形式：1001011，1就表示当前位需要累加

public class Fibonacci {
    // 时间复杂度: O(logN)
    public static int F3(int n){
        if (n < 1)
            return 0;
        if (n <= 2)
            return 1;
        // radix 就是上述的那个X
        int[][] radix = {{1, 1},
                         {1, 0}};
        int[][] res = matrixPower(radix, n - 2);
        return res[0][0] + res[1][0];
    }

    // 求方阵m的p次方,
    private static int[][] matrixPower(int[][] m, int p) {
        int N = m.length;
        int[][] res = new int[N][N];
        // 相当于矩阵中的单位矩阵
        for (int i = 0; i < N; i++)
            res[i][i] = 1;
        for (; p != 0; p >>= 1){
            if ((p & 1) != 0) // 说明最低位为1
                res = matrixMultiply(res, m);
            m = matrixMultiply(m, m);
        }
        return res;
    }

    private static int[][] matrixMultiply(int[][] m, int[][] n) {
        int rows = m.length;
        int cols = n[0].length;
        int[][] res = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                for (int k = 0; k < n.length; k++)
                    res[i][j] += m[i][k] * n[k][j];
            }
        }
        return res;
    }
    // 上面的这些技巧不仅仅是为了斐波那契相关的问题，还可以推广。如果有一组数，有严格的如下递推关系：
    // F[n] = a*F[n-1] + b*F[n-2] + ... + t*F[n-i] ，其中每个系数都可以为0，那么必然有：
    // [F[n],F[n-1],..,F[n-i+1]] = [F[i],F[i-1],..,F[1]] * i阶方阵的n-i次方       1⃣️。
    // 这个方阵就类似上面的X，是可以根据前几项推算出来的固定的值. 再推算基底方阵X的时候千万不要用1⃣️的公式，因为有矩阵次幂，会很复杂。
    // 推算基底方阵的时候，一般用递推公式：[F[n],F[n-1],..,F[n-i+1]] = [F[n-1],F[n-2],..,F[n-i]] * X
    // =====================================================================================================


    // 2.第一年农场有1只成熟的母牛A，往后的每年:
    //   1)每一只成熟的母牛都会生一只母牛
    //   2)每一只新出生的母牛都在三岁时成熟，刚出生那年是0岁
    //   3)每一只母牛永远不会死
    // 返回N年后牛的数量

    // 思路：F[1]=1 F[2]=2 F[3]=3 F[4]=4 F[5]=6 F[6]=9  先找出递推关系：F[n] = F[n-1] + F[n-3]
    //      所以可以确定基底方阵为3阶 由前几项可以求出基底方阵为       X = [[1, 1, 0]
    //                                                              [0, 0, 1]
    //                                                              [1, 0, 0]]
    // 所以，[F[n],F[n-1],F[n-2]] = [F[3],F[2],F[1]] * X的n-3次方

    public static int cow(int n){
        if (n < 5) // n<=0 返回0，n在1~4，返回n本身
            return Math.max(n, 0);
        int[][] radix = {{1, 1, 0},
                         {0, 0, 1},
                         {1, 0, 0}};
        int[][] res = matrixPower(radix, n - 3);
        return 3 * res[0][0] + 2 * res[1][0] + res[2][0];
    }
    // ====================================================================================================

    // 奶牛问题还可以进一步加大难度，假如牛在5岁的时候会死，那么求第n项为多少


    // 3.给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串。如果某个字符串任何0字符的左边都有1紧挨着,
    //    认为这个字符串达标。返回有多少达标的字符串

    public static void main(String[] args) {
        System.out.println(F3(6));
        System.out.println(cow(7));
    }
}
