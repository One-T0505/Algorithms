package Basic.Array;

// 给定一个整数组成的无序数组arr，值可能正、可能负、可能0。给定一个整数k，找到arr的所有子数组里，哪个子数组的累加和<=k，
// 并且是长度最大的，返回其长度。

// 这道题的最优解是：O(N)，即便流程非常复杂，但是这个模型也非常重要。下面来慢慢梳理。
// 首先需要两个和arr等长的两个数组，一个叫minSum，一个叫minSumEnd。
// minSum[i] 表示以arr[i]为头，能找到的最小累加和子数组是多少
// minSumEnd[i] 表示以arr[i]为头，能找到的最小累加和子数组时，对应的右边界索引
// 这两个数组是同步使用的；并且这两个数组的构造要逆序遍历。比如：arr= [5, -3, 2, 7, 0, -4, 1, 8, -2]
// minSum[7] = -2     minSumEnd[7] = 7
// 填写minSum[6]时，不需要再遍历，不然时间复杂度就不能控制在O(N)。只需要看一下右边的minSum[7]，发现以7开头能找到的最小累加和
// 是小于0的，所以以6开头往右扩是有价值的，所以 minSum[6] = arr[6]+minSum[7] ，并且minSumEnd[6] 和 minSumEnd[7] 保持
// 一致。每次构造以某个数开头能找到的最小子数组累加和时，只需要看下右侧是否有利可图就可以决定了，因为右侧已经帮你记录了右边的
// 状况，不需要你自己再去探索。

// 构建好两个辅助数组后，才能正式开始流程。假如以i元素开头如何找到长度最大且累加<=k的子数组？可以直接读取minSum[i]，
// 如果minSum[i] > k，那就是说从i～minSumEnd[i]中的任何子数组都不可能 <=k，所以以i开头不可能找到<=k的子数组了，
// 此时就要换头。
// 如果minSum[i] <=k，那就要转到minSumEnd[i]处，并且继续看minSum[i] + minSum[minSumEnd[i]+1] 是否 <=k，
// 所以minSum[i] <=k时，还需要继续向右扩展的行为，直到扩不下去。此时就找到了一个从i～x的最长子数组。

// 听了上面的流程你是不是以为时遍历整个数组，对每个元素都做上面的操作？那这样的话时间复杂度就不是O(N)了，就是O(N2)。
// 我们最开始，i就是0，我们找到了这样一个最大的子数组0～x后，x+1到最后的区域是我们尝试过但是没能继续加进来的区域；
// 所以我们让左边界0出窗口，现在窗口内就是1～x，看看此时还能不能继续吸纳新的区域进来，如果能就扩展，如果不能就一直弹出
// 左边界元素，直到左右边界重合时还不能拓展时，才换个新头。这样时间复杂度就是O(N)，因为窗口左右边界都不回退。
public class SubArrRangeSum {

    public static int longestSubArrUnderRangeSum(int[] arr, int k){
        if (arr == null || arr.length == 0)
            return 0;
        int N = arr.length;
        // 制作两个辅助数组
        int[] minSum = new int[N];
        int[] minSumEnd = new int[N];
        minSum[N - 1] = arr[N - 1];
        minSumEnd[N - 1] = N - 1;
        for (int i = N - 2; i >= 0; i--) {
            if (minSum[i + 1] <= 0) {
                minSum[i] = arr[i] + minSum[i + 1];
                minSumEnd[i] = minSumEnd[i + 1];
            } else {
                minSum[i] = arr[i];
                minSumEnd[i] = i;
            }
        }
        // 主流程
        // sum表示当前窗口内的累加和，end表示向右扩到不能再扩时，下一个区域的第一个位置
        int res = 0, sum = 0, end = 0;
        for (int i = 0; i < N; i++) {
            while (end < N && sum + minSum[end] <= k){
                sum += minSum[end];
                end = minSumEnd[end] + 1;
            }
            // 跳出while循环时，end可能有两种情况，1：刚好是不能再吸收区域的第一个位置；2：超过数组了，到了
            // N，不管是哪种情况当前找到的长度都是end-i
            res = Math.max(res, end - i);
            if (i < end)
                sum -= arr[i];
            else
                end = i + 1;
        }
        return res;
    }
    // 这道题目的模型非常重要
    // ====================================================================================================


    // 下面这道题的原型就是上面的模型：
    // 给定一个数组arr，给定一个值v，求子数组平均值小于等于v的最长子数组长度。

    // 思路：将原数组每个元素都减v，问题就转化为了--> 求子数组平均值小于等于0的最长子数组长度。这样转化有什么意义？
    //      求子数组平均值小于等于0，就等同于求子数组累加和小于等于 0 * 子数组长度 == 0，就可以变成直接
    //      求子数组累加和的问题了。
}
