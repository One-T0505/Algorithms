package Hard;

// leetCode587   凸包问题  这里用的最简单的 Jarvis 算法
// 给定一个数组 trees，其中 trees[i] = [xi, yi] 表示树在花园中的位置。
// 你被要求用最短长度的绳子把整个花园围起来，因为绳子很贵。只有把所有的树都围起来，花园才围得很好。
// 返回恰好位于围栏周边的树木的坐标。即返回最外围一圈的树的坐标

// 数据规模
// 1 <= points.length <= 3000
// points[i].length == 2
// 0 <= xi, yi <= 100
// 所有给定的点都是 唯一 的。

import java.util.Arrays;

public class SurroundGarden {

    // 先要了解一个数学知识：叉乘
    // 两个位置可以形成一个向量，如果两个向量的叉乘的结果为负数
    // 假设有a、b、c三个点，并且给出每个点的(x,y)位置
    // 从a到c的向量，在从a到b的向量的哪一侧？
    // 如果a到c的向量，在从a到b的向量右侧，返回正数
    // 如果a到c的向量，在从a到b的向量左侧，返回负数
    // 如果a到c的向量，和从a到b的向量重合，返回0
    private static int cross(int[] a, int[] b, int[] c) {
        return (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1]);
    }


    // 有了上面的这个方法后，就可以解决一些问题，比如：给你一个三角形，给你一个点，问该点是否在三角形内部
    // 思路：逆时针走三角形的三条边，按照向量的方式写出来三条向量。然后可以发现，如果该点在三角形内部，那么
    // 该点在每条向量的左侧。
    //     a             第4个点叫d，cross(a, b, d)   cross(b, c, d)  cross(c, a, d)
    //     /\            看三个返回值是否都为负数，若是，则d在该三角形内部
    //    /__\
    //   b    c
    //
    // 拓展：如果给你一个正常的凸多边形，问你一个点是否在该多边形内部，其方法和上面一模一样。


    // 主方法
    // 了解完了上面的铺垫之后，再来解决本题。先把给的所有点重新排序，x小的排前面，x相等，y小的排前面。
    // 我们需要准备一个栈。栈里的顺序我们认为是从栈顶到栈底，1，2，3.. 这样排序的
    // 我们先让最前面的两个点进栈
    // |a  b     于是 a、b就进栈了   默认有一个从栈次顶元素到栈顶元素的向量。从第3个点开始时，才有了进出栈规则：
    // 当第三个点x来的时候，如果 (次顶, x) 的向量在 (次顶, 顶) 的左侧，那么可以直接把当前点 x 入栈  那么现在栈里
    // 就有三个点了，顶和次顶也要相应发生改变。
    // 如果在其右侧，则弹出顶元素，那么就将新的顶元素、次顶元素、当前元素x继续做同样操作；如果弹出顶元素后，栈里只剩下
    // 1个元素了，那就直接让x入栈。

    // 该算法流程比较抽象，需要自己多举几个例子模拟一下，会发现，该算法的本质就是不断在维护最外围的边界情况。
    // 如果点的位置如下左图所示，那么运行完一遍算法之后，会变成如下右图
    //
    //  |                                  |
    //  |                                  |
    //  |        d•        •h              |         •        ● h
    //  | b•       e•                      |  •  •     •     /
    //  |     c•    f•                     |           •   /
    //  | a•           g•                  | a●-----------● g
    //  |__________________________        |__________________________
    //
    // 会有这样的连线，因为最后栈里 | a g h   这样的，表示 a->g->h 有连线
    // 但是这也只完成了一半，还记得我们排好序的点的数组吗
    // 现在再逆序运行一遍同样的算法，就可以将另一半边界给完成了。
    // 逆序运行了一遍了之后，栈里应该是：| h->d->c->b->a
    // 这里就涉及了一些去重问题。
    public static int[][] outerTrees(int[][] trees) {
        int N = trees.length;
        int[][] stack = new int[N << 1][]; // 这样肯定够用
        int size = 0; // 标记栈里存储了几个元素
        // 排序规则：按照x从小到大排序，x相等的，按照y从小到大排序
        Arrays.sort(trees, (a, b) -> (a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]));
        for (int i = 0; i < N; i++) {
            // 栈里剩余元素数量大于1  并且 在其右侧 才能弹出栈顶元素
            while (size > 1 && cross(stack[size - 2], stack[size - 1], trees[i]) > 0)
                size--;
            // 要么栈里只剩1个元素了，要么就是在其左侧了 总之就是可以将当前元素入栈了
            stack[size++] = trees[i];
        }
        // 这样栈里就完成了一半边界  接下来再逆序一遍

        // i从N-2开始，最后一个元素不用重复计算  因为正向运行时，N-1就和此时栈顶和次顶的两个元素算过了
        // 不管N-1怎么样，都不用又来一遍
        for (int i = N - 2; i >= 0; i--) {
            while (size > 1 && cross(stack[size - 2], stack[size - 1], trees[i]) > 0)
                size--;
            stack[size++] = trees[i];
        }
        // 去重   先将栈里存放的所有点按照上面一模一样的规则排序
        Arrays.sort(stack, 0, size, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);
        int n = 1; // n记录去重之后的元素下标  因为是覆盖 所以遍历的坐标 和实际不重复元素的坐标会不一样
        for (int i = 1; i < size; i++) {
            if (stack[i][0] != stack[i - 1][0] || stack[i][1] != stack[i - 1][1])
                stack[n++] = stack[i];
        }
        return Arrays.copyOf(stack, n);
    }
}
