package Hard;

// leetCode440
// 给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。
// 输入: n = 13, k = 2
// 输出: 10
// 解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。

// 1 <= k <= n <= 10^9

public class KthSmallNumInASCII {

    // 先了解一个结论：以某个数x开头，包含的数位<=n位的 有 11..11个(n个1)
    // 举例: 以3开头，包含的数位<=3位的数一共有几个？ <=3位的那就是1位 2位 3位的
    //      以3开头一共包含1位的只有3自己，所以是1个
    //      以3开头一共包含2位的有3_  30~39，所以是10个
    //      以3开头一共包含3位的有3__  300~399，所以是100个
    //      所以，以3开头，包含的数位<=3位的数一共有111个   这就有了上面的说的一般性结论.
    // 注意：这111个数都是以3开头的，我们这里只是为了计算数量，并不是说按字典序排序也是我们上面罗列的顺序！！

    // 有了上面的结论后，我们对原题意就可以做初步的分解。假设给了一个数 65327  我们可以把1～65327大致分为三个区间
    //  1.左侧  分别以1～5开头的，包含的总位数<=5的数，根据上面的结论可知一共有 5 * 11111 == 55555个
    //         不管这55555个数内部按字典序排序是什么样的，我们只知道这55555个数按照字典序必然排在 65327 前面
    //  2.右侧  右侧就是按照字典序必然排在65327之后的数字  那就是分别以7～9开头，总位数<=4位的所有数字。
    //          如果以7～9开头，且总位数==5的话，那就超过65327了，不在规定的1～65327这个范围了。根据上面的
    //          结论可以算出右侧有: 3 * 1111 == 3333个
    //  3.中间  仅以6开头，且总位数<=4位 + 60000~65327  == 1111个 + 5328个 == 6439个
    //         其实也可以用1～65327的总数量65327个 - 左侧 - 右侧  就得到了中间的数量
    //
    // 当分成了这样的三个区间后，就可以对k进行分类，看k落在了哪个区间里，就只用在那个区间里运行算法。
    // 所以，当给定一个数字后，提取其最高位的数字是很关键的，这样才能分区间。


    public static final int[] unit = {0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111};

    public static final int[] power = {0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};

    // 上面两个常量就是为了方便用的
    public static int findKthNumber(int n, int k) {
        int len = len(n);
        // 提取最高数位的数字，比如 num==65327  则len==5  我们应该造出 10000  该方法应返回最高位的6
        int highest = n / power[len];
        // 求左侧区间的数量。如果是上面的65327，则左侧是 5 * 11111个    如果最高位是1，则左侧数量为0，下面的
        // 公式依然符合
        // 这里的unit就代表了65327这个例子中的 11111
        int left = (highest - 1) * unit[len];

        int head = 0;
        int pre = 0;
        // 接着上面的分析继续深化问题。还是以65327为例子，其左侧有55555个，假如k==43210，那么k就落在了左侧区间，
        // 那么第43210个数到底是以谁开头呢？
        // 我们对左侧的55555个数进行粗略地排个序： 1开头的   2开头的  3开头的  4开头的  5开头的
        // 2开头的11111个数必然在所有的以1开头的数字之后，2开头的内部如何排序并不关心。所以 用 43210 / 11111 向上
        // 取整得到4，就说明第43210个数是以4开头的。那么43210是在以4开头的这一批数里的第几个呢？
        // 是 43210 - (4 - 1) * 11111 == 9877个
        // 当问题来到了求：以某个数字开头的一批数中字典序为第k个的数是多少 这就是最后一个任务了
        // kth这个方法就是解决这个问题的，之前做的工作都是为了这一步， 一步一步把问题拆解掉。

        // 落在了左侧区间
        if (k <= left) {
            head = (k + unit[len] - 1) / unit[len];  // 向上取整的写法
            pre = (head - 1) * unit[len];  // 前面的多少个
            // 先去理解下面对kth方法的解读，然后再来看这里。我们知道第一个参数是范围限制，又因为
            // 左侧区间的数在数值上必然都不会超过n，所以第一个参数填n是没用的。如果我们分析到了目标数是在4开头的这批
            // 数里，那么我们给的限制应该是49999，下面的公式就是算这个限制的。先找出开头元素head
            // (4 + 1) * 10000 - 1 == 49999   k-pre 表示 要求的数在以4开头的这批数里排第几
            return kth((head + 1) * power[len] - 1, len, k - pre);
        }
        // 执行到这里说明 k 不属于左侧区间
        // 算中间区间的数量  下面还是按照65327这个例子来算
        //           1111       +     5327       + 1     最后的这个1就表示60000这个数
        int mid = unit[len - 1] + (n % power[len]) + 1;
        if (k <= left + mid) {  // 落在了中间
            // 只有在中间区间时，第一个参数传n才有用。因为中间区间是以6开头的一批数，我们的上限就是65327，
            // 但是以6开头，位数<=5的，还有65328～69999这些，所以要填n做限制
            return kth(n, len, k - left);
        }
        // 执行到这里说明 k 属于右侧区间  那么 k 就应该是右侧区间的第 k - left - mid 个
        k -= left + mid;
        len--;
        // 这里的逻辑其实和左侧的一样
        head = (k + unit[len] - 1) / unit[len] + highest;
        pre = (head - highest - 1) * unit[len];
        return kth((head + 1) * power[len] - 1, len, k - pre);
    }


    // 给定一个数字n，求n有几位数
    private static int len(int n) {
        int count = 0;
        while (n != 0) {
            n /= 10;
            count++;
        }
        return count;
    }


    // 举例：kth(65327, 5, 1203)   n就是传入的一个数，我们现在以传入的n的最高位为要求：
    // 仅以n的最高位开头，且总位数<=5位的，并且<=65327的这些数中，字典序第1203个是多少
    // 所以，第一个参数n有两个作用：
    //  1.告诉我们最高位是多少，我们只能枚举以最高位开头，且位数<=len的数字
    //  2.符合第1点的要求外，还要保证枚举的这个数字不能超过n，所以n还保证了上界

    // 这个方法的逻辑其实和主逻辑类似，还是要将区间分成三部分  左中右
    // 因为这个方法已经将范围确定在了以某个数开头，总位数<=len的范围中了
    // 再继续分，就得按照次高位来分了。 就以65327为例子  kth(65327, 5, 1203)
    // 如果k==1，那直接返回最高位单独一个数6  如果不是那就让k-1  也就是说排除了这批数里的第一个数6，从后面开始算
    // kth(65327, 5, 1202)
    // 1.左侧：开头固定是6，次高位是0，且除去开头的位数<=4的一共有几个 即 60___
    //        一直到64___    这些就是左侧的  一共有 5 * 1111 == 5555个
    // 2.中间：开头是6，次高位是5，65___ 一共有几个，且不超过65327这个范围  111 + 237 + 1 == 349个
    // 3.右侧：开头是6，次高位是6～9，且除去最高位的位数<=3个的个数，如果除去最高位还有4位，那就超过65327范围了

    private static int kth(int n, int len, int k) {
        // 这个参数 effect 就表示n这个数是否还能限制。如果k落在了中间区间，那么n还能起限制作用，如果落在两边
        // 就说明n无法限制了，得设置新的值。
        boolean effect = true;
        int res = n / power[len]; // 最高位
        while (--k > 0) { // 判断k是否为1
            n %= power[len--];
            int head = 0;
            if (!effect) {
                head = (k - 1) / unit[len]; // 因为最高位已经有数了，所以现在次高位可以从0开始
                res = res * 10 + head;
                k -= head * unit[len];
            } else {
                int highest = n / power[len];  // 其实求的是次高位的数
                int left = highest * unit[len]; // 可以为0
                // 如果k落入了左侧，那么其上限就是..99 这样的9结尾的数，实际的数n已经无法约束了
                if (k <= left) {
                    effect = false;
                    head = (k - 1) / unit[len];
                    res = res * 10 + head;
                    k -= head * unit[len];
                    continue;
                }
                k -= left;
                int mid = unit[len - 1] + (n % power[len]) + 1;
                if (k <= mid) {
                    res = res * 10 + highest;
                    continue;
                }
                effect = false;
                k -= mid;
                len--;
                head = (k + unit[len] - 1) / unit[len] + highest;
                res = res * 10 + head;
                k -= (head - highest - 1) * unit[len];
            }
        }
        return res;
    }


}
