package Hard;

// LCP03
// 力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人
// 就会无限循环这条指令的步骤进行移动。指令有两种：
//  U: 向y轴正方向移动一格
//  R: 向x轴正方向移动一格。
// 不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。
// 给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。

// 数据规模
// 2 <= command的长度 <= 1000
// command由U，R构成，且至少有一个U，至少有一个R
// 0 <= x <= 10^9, 0 <= y <= 10^9
// 0 <= obstacles的长度 <= 1000
// obstacles[i]不为原点或者终点

import java.util.HashSet;

public class ProgrammableRobot {

    // (x, y)是终点  先讲解一下主思路：
    // 先看完主方法里的三段注释再回来这里。
    // 因为是循环执行指令，所以坐标的变化都有规律可循。我们先把一轮之内坐标可能的改变记录在一个集合里，
    // 就是主方法里的set的作用。比如command == URRUR
    // 那么可能的坐标变化就是：(0, 1)  (1, 1)  (2, 1)  (2, 2)  (3, 2)
    // 这些坐标对，就是说相对于开始执行这一轮指令开始时点的位置的变化。执行第一个U，坐标就会在y上+1 所以就是(0, 1)
    // 只用记这一遍就行了，因为指令的循环执行，下一轮执行时，其变化趋势和这一模一样
    // 但是如何将这些坐标对存储起来呢？很简单，传统的做法就是 "0_1" "1_1" 以字符串拼接的形式就能存储了
    // 但是这里我们用了一种更高级的存储方式，为了便于理解，这里先不讲如何存储的，你只需知道我们已经把趋势
    // 存好在了set中，下面用两段虚线包围起来的代码就是用于存储的代码。
    // 存储好了以后，我们如何利用这些趋势来帮助我们解题呢？ 下面举例来说明：
    // 假设最终的终点是 (17, 33)  起点是(0, 0)  指令还是上面的指令  所以执行一轮指令后
    // 坐标最终会变化 (3, 2)
    // 用 17 / 3 == 5   33 / 2 == 16   再取最小值得到5，也就是说我们至少会完整得执行5轮指令
    // 执行了5轮指令后，坐标到了 (3 * 5, 2 * 5) --> (15, 10)  以此为新起点 去 (17, 33)
    // 那就还剩 (2, 23)  其实就是说可以把(15, 10)这个点当作(0, 0)  那么终点就变成了 (2, 23) 相对位置嘛
    // 然后我们只需要查一下我们记录在集合里的趋势中是否存在(2, 23)这个记录，如果存在，就说明可达，不存在就说明
    // 不可达。这就是我们为什么要记录这个趋势。

    // 下面来讲解这个高级的存储方法
    // 由题目给的数据规模可知  2 <= command.length <= 1000
    // 所以一条指令的变化趋势不可能让X变化超过1000，也不可能让Y的变化超过1000。我们取1024，刚好是2的10次方
    // 也就是说我们用int的10位就可以完全装得下。所以我们使用int型数据32位中最低的10位表示Y的变化，用10～19这
    // 10位来记录X的变化。那么上面的(3, 2)就变成了：
    // 000000000000 0000000011 0000000010    只需要让 (3 << 10) | 2 即可 通用公式 (X << 10) | Y
    // 所以，这样就能看懂下面的代码了

    public static boolean robot(String command, int[][] obstacles, int x, int y) {
        // -------------------------------------------
        // 将command的完整坐标变化趋势记录在set中
        int X = 0;
        int Y = 0;
        HashSet<Integer> set = new HashSet<>();
        for (char c : command.toCharArray()) {
            X += c == 'R' ? 1 : 0;
            Y += c == 'U' ? 1 : 0;
            set.add((X << 10) | Y);
        }
        // -------------------------------------------

        // meet函数作用是从起点(0,0)能否到达，(x,y)终点  这里的能否到达是指不考虑路上遇到障碍的情况
        // 仅考虑通过command 是否能到(x, y)点，先不考虑碰到障碍的事，先考虑能否通过这样的命令到达这个坐标
        // 如果连这个坐标都达不到，就根本不用考虑碰不碰得到障碍了
        if (!meet(x, y, X, Y, set))
            return false;
        // 如果能碰到终点这个坐标，这时候才考虑command规划的路线上是否会碰到障碍
        // 但凡碰到一个障碍就失败
        for (int[] ob : obstacles) {
            // 下面的if表达的是 只有 障碍的坐标 在终点范围之内才用考虑，如果障碍的坐标在终点的右侧或者上侧，
            // 命令里又不能使用向下和向左的指令，那么这些障碍就必不可能碰到。
            // 只考虑那些在终点范围内的障碍
            if (ob[0] <= x && ob[1] <= y && meet(ob[0], ob[1], X, Y, set))
                return false;
        }
        return true;
    }


    // 默认起点是(0, 0)
    // (x, y)是终点   (X, Y) 是执行完一轮执行后坐标的最终变化
    // set里记录了执行一轮指令时所有的变化
    // 返回能否到达(x, y)  再不考虑障碍的情况下，仅考虑的位置关系
    private static boolean meet(int x, int y, int X, int Y, HashSet<Integer> set) {
        if (X == 0) // X == 0说明不管怎么执行指令，都只在x==0这一条直线上移动
            // 如果终点的x是0，那么肯定会到；如果x不是0，那肯定到不了
            return x == 0;
        if (Y == 0)
            return y == 0;
        // (X, Y)均不为0
        // 至少执行完整的几轮指令
        int least = Math.min(x / X, y / Y);
        // 剩下的坐标
        int rx = x - least * X;
        int ry = y - least * Y;
        // 说明刚好执行完完整几轮指令后，就到了终点
        // 为什么要单独拿出来判断呢？
        // 你有没有发现，我们记录的变化趋势，其实就是走1步、走2步、执行完指令的最后一步，分别对应的坐标
        // 变化量，我们考察的都是从当前位置走1步是不是终点？走2步是不是终点？...
        // 而从来没考虑当前开始位置是否就到了终点
        if (rx == 0 && ry == 0)
            return true;
        else
            return set.contains((rx << 10) | ry);
    }
}
