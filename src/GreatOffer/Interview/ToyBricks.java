package GreatOffer.Interview;

import java.util.Arrays;

// 来自京东笔试
// 小明手中有n块积木，并且小明知道每块积木的重量。现在小明希望将这些积木堆起来
// 要求是任意一块积木如果想堆在另一块积木上面，那么要求:
//  1) 上面的积木重量不能小于下面的积木重量
//  2) 上面积木的重量减去下面积木的重量不能超过x
//  3) 每堆中最下面的积木没有重量要求
// 现在小明有一个机会，除了这n块积木，还可以获得k块任意重量的积木。小明希望将积木堆在一起，
// 同时希望积木堆的数量越少越好，你能帮他找到最好的方案么?
// 输入描述:
//  第一行三个整数n,k,x, 1<=n<=2*10^5，0<=x, k<=10^9
//  第二行n个整数，表示积木的重量，任意整数范围都在[1 , 10^9]
// 样例输出:
//   13  1  38
//   20 20  80  70 70 70 420 5 1 5 1 60 90
//  输出: 2
// 解释: 两堆分别是 1 1 5 5 20 20 y 60 70 70 70 80 90
//                420
// 其中y是一个任意重量的积木，夹在20和60之间可以让积木继续往上搭


public class ToyBricks {

    // 根据数据量可知，最后的时间复杂度只能和n有关。很容易想到要先对积木的重量从小到大排序
    // 然后在不使用魔法积木的情况下，看会分成几堆。
    // 这里涉及到了第一个贪心：就是每一堆中尽可能让两块积木的重量差最小，这样一堆里能放下的积木数量才能最大化，并且
    // 在一堆中可以继续堆的情况下没必要开一个新堆，所以在有序数组中，直到碰到不能继续堆叠的积木时才有必要开一个新堆。
    // 第二个贪心：将数组分成若干堆后，两两堆之间都有一个差额，用魔法积木去粘合两个差额最小的堆的收益是最大的。比如：
    // 第一个堆：[1, 1, 4, 7, 7]  第二个堆：[21, 22, 24， 26]   第三个堆：[33, 36, 38, 38, 41]
    // x==6  堆1和堆2的差额为14  堆2和堆3的差额为7
    // 如果去粘合堆1和堆2，至少需要2块魔法积木，但是粘合堆2和堆3只需要1块

    public static int minSplit(int[] arr, int x, int k) {
        Arrays.sort(arr);
        int N = arr.length;
        // 差额数组，diff[0]表示堆0和堆1的差额，只用一个diff数组就可以知道两个堆之间的差额，并且还能知道堆的数量
        int[] diff = new int[N];
        int heaps = 1;  // 已经分成几堆了
        int size = 0; // 表示应该填写diff[size]这个位置的值了 size刚好可以表示分成了几堆
        for (int i = 1; i < N; i++) {
            if (arr[i] - arr[i - 1] > x) {
                heaps++;
                diff[size++] = arr[i] - arr[i - 1];
            }
        }
        // 如果全部积木直接可以全部堆在一起 或者 x不合理 直接返回
        if (heaps == 1 || x == 0)
            return heaps;
        // 将差额从小到大排序
        Arrays.sort(diff, 0, size);
        // 粘合差额的公式为：(diff[i] - x) / x  的向上取整  -->  (diff[i] - x + x - 1) / x == (diff[i] - 1) / x
        // 这个公式是可以自己推出来的，后面只不过是把向上取整变成了计算机好实现的方式
        for (int i = 0; i < size; i++) {
            int need = (diff[i] - 1) / x;  // 粘合当前的差额需要的魔法积木数量
            if (k >= need) {
                heaps--;
                k -= need;
            } else
                break;
        }
        return heaps;
    }
    // ===================================================================================================


    // 上面的是最优解，涉及了两个贪心点，一开始并没有那么容易想出来。
    // 下面的方法是启发式方法，利用递归写出基本尝试。下面来介绍该递归函数的含义：
    // 当前来到了第i块积木来做决策，可以分堆也可以粘合进之前元素所在的堆。x是固定参数，r表示还有几块魔法积木可以使用
    // 该方法返回从i到最后的这些积木最少分成几个堆
    // i位置的积木已经在一个堆里了，不管是新堆还是旧堆，总之i的位置已经决定好了，现在要做的是决策：i和i+1是应该在一个堆里
    // or 让i+1开个新堆 or 用魔法积木将i+1粘合进i的堆
    // 所以，看似传入的参数是i，实际上是要决策i+1的去留
    public static int f(int[] arr, int i, int x, int r) {
        // i位置是开成新堆还是继续粘合进旧堆是上一个元素决定的，并且每个堆是该堆中最后一个元素来结算的
        if (i == arr.length - 1)
            return 1;
        // 还没到最后一个元素
        if (arr[i + 1] - arr[i] <= x) // 必然让i+1元素粘合进旧堆里
            return f(arr, i + 1, x, r);
            // 用魔法积木粘合或者分堆
        else {
            // 分堆
            // 如果是分堆了，那么i就是旧堆的最后一个元素，此时做的决定后，旧堆就确定了，于是可以把旧堆加上了
            // 这就是上面说的堆里的最后一个元素来结算当前堆
            int p1 = 1 + f(arr, i + 1, x, r);
            // 粘合
            int p2 = Integer.MAX_VALUE;
            // 还要看魔法积木的数量是否够用于粘合
            int need = (arr[i + 1] - arr[i] - 1) / x;  // 公式: (差额 - 1) / x
            if (r >= need)
                p2 = f(arr, i + 1, x, r - need);

            return Math.min(p1, p2);
        }
    }
    // 写完这个尝试后，发现其可变参数为i和r 其范围超过了10^8，所以必不可行，一定要省略r这个参数，那么可以省略这个参数
    // 就说明不是什么时机都可以去弥合的，所以弥合的时机必然是可以通过贪心选择出来的。
    // 有了这个尝试后会启发想出最优解
}
