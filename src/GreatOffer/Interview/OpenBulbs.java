package GreatOffer.Interview;

// n个灯泡排成一行，编号从 1 到 n。最初，所有灯泡都关闭。每天只打开一个灯泡，直到n天后所有灯泡都打开。
// 给你一个长度为n的灯泡数组 blubs ，其中 bulbs[i] = x 意味着在第 (i+1) 天，我们会把在位置 x 的灯泡打开，其
// 中 i 从 0 开始，x 从 1 开始。
// 给你一个整数k，请返回恰好有两个打开的灯泡，且它们中间正好有k个全部关闭的灯泡的最小的天数。如果不存在这种情况，
// 返回 -1 。
// 比如：k==4， 第1天点亮了2号灯， 第2天点亮了4号灯，第3天点亮了9号灯，第4天点亮了14号灯，
//      于是返回3；因为第3天点亮了9号灯后，4和9之间刚好隔了4个全黑的灯泡；当然第4天点亮14号灯后，9和14也符合要求，
//      但是i题目说返回最小的，即最早出现符合要求的天数，所以应该返回3。

// n == bulbs.length
// 1 <= n <= 2 * 10^4
// 1 <= bulbs[i] <= n
// bulbs 是一个由从 1 到 n 的数字构成的排列
// 0 <= k <= 2 * 10^4

public class OpenBulbs {


    // 思路：我们先把给的数组转换成我们需要的预处理结构，我们想做这样一种数组open，open[i]表示i+1号灯在哪一天
    // 被打开。这里要注意坐标索引的转换，因为题目给的灯泡编号是从1开始。举例模拟算法流程：
    // 假如k==4，并且我们需要的open数组也做好了。此时就是要维持一个大小为4的窗口，然后窗口左边的灯x和右边的灯y就是
    // 要被验证的目标对，如果open[x]==10,  open[y]==6  我们取两者的最大值10，如果窗口内的4个值都 > 10，说明
    // x和y中间隔的这4盏灯的开放时间都晚于x、y，所以x和y是符合的，这样才算成功，如果不成功，就让窗口右移，遍历即可。
    // 为什么取x、y的最大值，因为两个灯此时是开的，所以必然时间已经来到了两者较晚打开的时间。

    // 这还不是最快的，还有更快的小技巧。比如 k==4，open数组某一段如下：
    // 12  15  16  9  19  10  13 要验证的是12和10这对，当验证窗口内的4盏灯时，15和16通过验证了，而9验证失败了，
    // 如果按照上面的做法就是让窗口移动到 [16 9 19 10]  再去验证15和13，这样就慢了；
    // 这样想，因为上一步验证12和10的时候，15和16是通过的，而到了9才失败，也就是说通过的都是大于12的，那么把窗口
    // 往下移一步，9依然在15做窗口边界和16做窗口边界时的内部，这两次验证也必然失败，所以我们可以直接让窗口移动到
    // 9做左边界，这样9就不用再做之前验证通过元素的窗口内部元素了，这样就能加快了

    // 还有一个点：就是当(12,10)这对在验证时15通过验证了，并且15的通过也告示了以15为窗口左边界时的失败！！！
    // 你想，15通过了，就说明15是比此时12和10大的，所以当窗口右移到15为窗口内左边界时，此时的外边界10就变到了
    // 窗口内部，也就是说窗口内部已经出现了比15小的数，明白了吗
    // 所以，假如一个i位置的数通过了验证，同时也昭告了(i, i + k + 1)这对数对的失败。
    // 所以当整个窗口验证都通过了，可以收集答案的时候，下一次需要验证的数字对就变成了(L-1, R + 1)-->(R+1,R+2+k)
    // L R是窗口内边界，L-1和R+1就是需要验证的数字对

    public static int kEmptySlots(int[] bulbs, int k) {
        if (bulbs == null || bulbs.length < k + 2)
            return -1;
        int res = Integer.MAX_VALUE;
        int N = bulbs.length;
        int[] open = new int[N];
        // 这里我们采用的是灯泡改成从0开始编号，天数从1开始
        for (int i = 0; i < N; i++) {
            open[bulbs[i] - 1] = i + 1;
        }
        // 正式算法流程
        // L和R分别表示窗口的两个边界 这里我们直接让窗口大小为k+2，这样窗口的左右边界就是要验证的数字对
        int L = 0;
        int R = L + k + 1; // 执行到这里说明N >= k + 2 最上面旧堆长度筛选了
        while (R < N) {
            int late = Math.max(open[L], open[R]);
            // next表示下一次L要移动到哪
            // 因为下面的for循环有可能一直都通过，而不会对next有修改的，所以要让他默认设置为全部通过的情况
            int next = R;
            boolean succeed = true;
            for (int i = L + 1; i < R; i++) {
                // 验证失败，说明整体失败
                if (open[i] <= late) {
                    next = i;
                    succeed = false;
                    break;
                }
            }
            if (succeed)
                res = Math.min(res, late);
            L = next;
            R = L + k + 1;
        }
        return res == Integer.MAX_VALUE ? -1 : res;
    }


}
