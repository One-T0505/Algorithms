package GreatOffer.class39;

import java.util.Stack;

// 来自腾讯
// 给定一个长度为n的数组arr, 求有多少个子数组满足:
// 子数组两端的值，是这个子数组的最小值和次小值，最小值和次小值谁在最左和最右无所谓
// n<=100000

public class _02_Code {

    // 总体流程：
    // 先从左到右遍历数组，每次让当前元素作为子数组的右边界，且为子数组的最小值，能找到多少个这样的子数组
    // 再从右到左遍历数组，每次让当前元素作为子数组的左边界，且为子数组的最小值，能找到多少个这样的子数组
    // 把所有的答案累加上就是答案

    // 这道题目要用到单调栈来完成上述流程   假设给定的数组为：[2, 3, 2, 3, 2, 1, 4, 3, 1, 2, 2, 3]
    // 单调栈要求从栈底到栈顶按照从小到大的顺序排列，相同值的元素压在一起
    // 先模拟从左至右的遍历：
    //   0位置的2直接入栈，1位置的3发现栈顶元素为2，3>2，所以3直接入栈，栈里的情况是：[2, 3]
    //   来到2位置的2时，此时要弹出3元素，此时就可以结算了，但是结算的对象不是被弹出的元素3，而是触发弹栈操作的元素2，
    //   此时被弹出的元素3作为子数组的左边界，当前元素2作为子数组的右边界，且右边界的2是子数组的最小元素，符合我们的
    //   要求，所以以2位置的2为子数组右边界且为子数组最小值的子数组我们找到了一个，那就是3~2，3和2中间如果有比3大的
    //   值一定会压在3上面；所以说，当有一个元素可以让栈弹出元素时，弹出几个就可以为当前元素结算几个答案。当弹出3后，
    //   栈顶元素2和当前元素相等，于是压在一起  栈里变成了：[(2,2个)]
    //   3位置的3直接压栈，[(2,2个), 3]  4位置的2将栈顶弹出，结算一个答案，再把2压在一起  [(2,3个)]
    //   5位置的1让栈顶的2弹出，因为有3个2，所以为1结算3个答案，这里有一个很重要的点：如果弹出的元素数量>=2个，
    //   那么还需要进行内部结算，如果被弹出的元素出现了n次，n>=2，那么内部结算的公式：C(n,2)  因为这n个元素，
    //   任意挑选两个组成边界的子数组都满足要求。为什么可以进行内部结算？可以这样想：如果有若干个相等的元素压在了一起，
    //   比如：a...a...a...a  在栈里形成了4个a压在一起，第一个a和第二个a之间的元素必然大于a，如果有小于a的，那么第
    //   一个a就会被弹出，无法形成4个a压在一起的局面；所以任意两个a之间的元素都是大于a的。
    //   当过完一遍数组后，栈里的情况是：[(1,2个), (2,2个), 3]  如果遍历完数组，栈里不空，那么还要单独结算
    //   这时每个元素只能进行内部结算了，如果某个元素的次数>=2就可以内部结算。
    //
    // 再模拟从右至左的遍历：
    //   从右至左的遍历一样，只不过这次结算时，是让当前元素作为子数组的左边界且最小值的情况来结算的，因为你只知道
    //   右侧的情况，所以自己只能作为左边界了。并且，这一次遍历不需要再做内部结算了！！！！！

    // 主方法
    public static int subArray(int[] arr) {
        if (arr == null || arr.length < 2)
            return 0;
        int N = arr.length;
        Stack<Node> stack = new Stack<>();
        int res = 0;
        // 从左到右的遍历
        for (int i = 0; i < N; i++) {
            while (!stack.isEmpty() && stack.peek().val > arr[i]) {
                Node cur = stack.pop();
                res += cur.times;
                if (cur.times >= 2)
                    res += (cur.times * (cur.times - 1)) >> 1;
            }
            // 此时跳出while后，有三种情况：栈空   栈不空且栈顶等于当前值   栈不空且栈顶小于当前值
            if (!stack.isEmpty() && stack.peek().val == arr[i]) { // 情况2
                stack.peek().times++;
            } else {  // 情况1和情况3
                stack.push(new Node(arr[i], 1));
            }
        }
        // 单独处理剩下的
        while (!stack.isEmpty()) {
            Node cur = stack.pop();
            res += cur.times >= 2 ? (cur.times * (cur.times - 1)) >> 1 : 0;
        }

        // 从右到左的遍历
        for (int i = N - 1; i >= 0; i--) {
            // pop用于记录当前元素让多少元素弹栈了，记录了内部结算和正常结算的总和
            // 不用内部结算了
            while (!stack.isEmpty() && stack.peek().val > arr[i]) {
                Node cur = stack.pop();
                res += cur.times;
            }
            // 此时跳出while后，有三种情况：栈空   栈不空且栈顶等于当前值   栈不空且栈顶小于当前值
            if (!stack.isEmpty() && stack.peek().val == arr[i]) { // 情况2
                stack.peek().times++;
            } else {  // 情况1和情况3
                stack.push(new Node(arr[i], 1));
            }
        }

        return res;
    }

    // 该结构就是专门封装的结点来压栈
    public static class Node {
        public int val;
        public int times;

        public Node(int val, int times) {
            this.val = val;
            this.times = times;
        }
    }


    // 看完上面的算法过完，会发现这个算法非常值得推敲。当栈里是如下情况时：2 3 4
    // 此时来了个1，会让4弹出，首先可以肯定的是 4～1 之间没有比4小的数，如果有早就把4弹出去了，所以
    // 当弹出4结算时，此时[4,1]构成的数组就是1作为右边界并且还是最小值，而且4作为左边界并且是次小值，不可能有比4小的数。
    // 当弹出3时也是这样的，很巧妙地3就是次小值了。因为3～1之间只可能比3大。

    // 此外，题目的意思给地比较复杂，我们的解法很巧妙地只使用了单一的原则就做到了题目的要求，这里启示我们要把
    // 题目要求拆分成比较基本的问题。当我们从左到右遍历时，我们找的是每个元素作为右边界最小值的情况，而从左到右
    // 遍历到某个元素时，我们找的是该元素作为左边界最小值的情况，所以每个元素，都会以自己为最小值，分别向左和向右
    // 找寻所有可能性。

}
