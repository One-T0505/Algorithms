package class14;

import utils.arrays;

// leetCode41
// 给定一个无序数组，值可正可负可0，找出数组缺失的最小正整数。
// 要求：时间复杂度O(N)  空间复杂度O(1)

public class MinAbsentNum {

    // 空间复杂度为O(1)，彻底杀死了用哈希表的想法。只能在数组本身上玩，并且只能有有限几个变量。
    // 思路是：尽量做到i位置放的元素是i+1，因为是想收集正整数。先这样想，假设数组arr长度为N，那最差的情况
    // 就是这N个数是1～N，那么要返回的结果就是N+1，这是缺失值的最大可能性了，不可能再比N+1大了。
    // 用一个L记录有效区，R记录垃圾区，这和荷兰国旗的思路差不多，左边记录某个区域，不需要的往右边放。
    // R最开始为N，因为还没形成垃圾区；同时R+1也表示最差的预期。下面用实际例子过一下：
    //
    // 3  -2  3  4  7  -1  0  5  2  6            在还没遍历数组时，我们的有效区是：1～10，因为数组长度为10
    // 0  1   2  3  4  5   6  7  8  9            L=0，R=10
    //
    // 3在效范围内，他应该放在2位置上，但是2位置上本身就是3，所以3就无效了，因为这么一个重复数字，导致浪累了一个空间
    // 所以有效范围变为：1～9；R--，然后把0上的3和R交换，于是0位置上来了6，继续分析6在有效范围内，5位置上不是6，
    // 那么再把0和5位置交换，0位置上此时是-1，-1为无效数，于是R--，再交换，再把有效范围变为：1～8；此时的数组如下：
    //
    // 2  -2  3  4  7  6  0  5  -1  3                  此时，0位置的2在有效范围内，并且1位置上不是2，所以交换
    // 0  1   2  3  4  5  6  7  8   9                  有效范围不变。0位置上此时为-2，无效，R--，再和R交换，
    // L                        R
    //
    // 并把有效范围变为：1～7；0位置此时为5，在有效范围内，并且4上不是5，所以交换过去，有效范围不变。此时0位置上是7，
    // 在有效范围内，并且6位置上不是7，于是交换。此时0位置上为0，无效数字，R--，0和R交换，有效范围变为：1～6。


    public static int minMissingPositive(int[] arr) {
        if (arr == null || arr.length == 0)
            return 1;
        if (arr.length == 1)
            return arr[0] == 1 ? 2 : 1;
        // L就是我们需要来做判断的位置    如果L==5，那就说明arr[0..4]位置上已经排好了1～5。
        int L = 0;
        int R = arr.length;
        while (L < R) {
            if (arr[L] == L + 1)
                L++;
                // 就像上面说的，如果L来到了5，那么arr[L]<=5，都无效了
                // R其实就控制着有效范围的上边界，如果超过了R，那肯定无效
            else if (arr[L] > R || arr[L] <= L || arr[arr[L] - 1] == arr[L])
                arrays.swap(arr, L, --R);
            else
                arrays.swap(arr, L, arr[L] - 1);
        }
        return L + 1;
    }


    // 上面的问题就是原模型。字节考过一个原题：给定一个无序数组，值可正可负可0，给定一个自然数k，
    // 请找出数组中缺失的>k的最小正整数。
    // 该问题只需要把原数组中每个元素减去k就变成了原模型。
}
