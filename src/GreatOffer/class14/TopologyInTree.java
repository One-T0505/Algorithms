package class14;


// 从二叉树的某个节点x开始，往下子节点都要的，叫子树;在二叉树上只要能连起来的任何结构，叫子拓扑结构.
// 返回二叉树上满足搜索二叉树性质的、最大子拓扑结构的节点数.
//
//       6
//     /   \            像这样的，可以选择的最大拓扑结构就是          5
//    1     5                                                 /   \
//        /   \                                              3     6
//       3     6                                              \
//     /   \                                                   4
//    7     4
//

public class TopologyInTree {

    // 这个也是二叉树递归套路。我们先定义一种信息，以当前结点为根的子树上能找到的最大拓扑结构的结点数量。
    // 比如上面的 3子树的信息就是2，因为能找到的最大拓扑结构就是3->4这两个结点，6只能返回1。这些信息
    // 都是基于当前结点为根的情况下统计出来的有效结果，当收集到了左右子树的有效信息后，我们如何整合他们的信息
    // 获得自己的信息是这道题目的难点。
    //
    //                  950
    //                                 此时来到了结点950，其左子树的信息已经完全手机好了。此时左子树上的信息
    //       700                       还都只是对700负责的数据，30的含义是：700的左子树上一共能找到30个结点
    //    50/   \ 30                   不违反BST规则。现在来到了950，我们如何将950的左子树的信息快速整合成
    //           \                     关于950的信息？
    //           800                   先看700的左子树提供的50个结点，这50个结点必然<700，所以也必然<950
    //        12 / \ 17                所以当700连在了950的左子树上时，这50个结点同样完全可以符合规定，也就
    //              \                  是说这50个可以全部对950负责，直接平行移植了。
    //              900                再看700的右子树的情况。800可以整体放在950的左子树上，所以800左子树以及
    //            5 / \ 11             800本身这一共13个结点可以为950负责，但是850右子树的情况还未知，要继续
    //                 \               往下看。900<950，所以放在950的左子树上没问题，所以900的左子树及自己
    //                 1000            一共6个结点可以平行移植。来到1000时，发现1000>950，将1000放在950的
    //               5 /  \ 5          左子树上就违反规定了，所以以1000为根的子树提供的数量都不可取，直接砍掉
    //                     \           这11个结点。于是我们就通过950的左子树的信息分析得到了关于自己的左子树
    //                                 信息。就是需要遍历一遍左子树的右边界。
    //
    // 当我们整合950的右子树的信息时，就只需要遍历950右子树的左边界一遍即可。

    // 这个题目和传统的二叉树递归套路不一样，因为950在整合左子树的信息时，不光只利用了左子树的信息，还需要下面
    // 每一层的信息，所以我们需要全局的缓存，每个结点都可以访问全局的信息。
    //

    // h: 代表当前的头节点
    // t: 代表树 t[i][0]是i节点的父节点的值、t[i][1]是i节点的左孩子的值、t[i][2]是i节点的右孩子的值
    // m: i节点为头的最大BST拓扑结构大小 -> m[i]
    // 返回: 以h为头的整棵树上，最大BST拓扑结构的大小

    // m就是这个全局缓存，每一层递归都可以查找全局信息
    public static int maxBSTTopology(int h, int[][] t, int[] m) {
        // 因为根结点的编号从1开始，所以当传入的结点变成0了，就说明走到null了，遍历到树的最下面的空了
        if (h == 0)
            return 0;
        int L = t[h][1]; // 左孩子的值
        int R = t[h][2]; // 右孩子的值
        int c = 0;   // 统计要删除的结点，可以类比成1000向上提供的11个结点
        // 收集左右孩子信息
        int p1 = maxBSTTopology(L, t, m);
        int p2 = maxBSTTopology(R, t, m);

        // 这就是遍历左孩子的右边界。如果比当前结点小，那么就可以一直往下走，直到碰到类似于上面的1000那样的
        // 违法结点，或者走到底碰到空
        while (L < h && m[L] != 0) {
            L = t[L][2];
        }
        // 此时L要不就是比根大，要不就是到空结点了
        if (m[L] != 0) { // 判断是否走到空了
            c = m[L];  // 没走到空，说明此时L来到了像1000这样的非法结点，将其提供的结点记录下来
            // 然后回溯，沿途结点的数量都要更新，因为上面的结点也都不可以要这1000提供的c个数量
            while (L != h) {
                m[L] -= c;
                L = t[L][0];
            }
        }

        // 这就是访问右子树的左边界
        while (R > h && m[R] != 0) {
            R = t[R][1];
        }
        if (m[R] != 0) {
            c = m[R];
            while (R != h) {
                m[R] -= c;
                R = t[R][0];
            }
        }

        // 整合自己的信息
        m[h] = m[t[h][1]] + m[t[h][2]] + 1;
        return Math.max(Math.max(p1, p2), m[h]);
    }
}
