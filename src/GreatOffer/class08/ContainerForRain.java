package class08;

// leetCode11
// 给定一个长度为 n 的无重复整数数组height。有n条垂线，第 i 条线的两个端点是(i, 0)和(i, height[i])。
// 找出其中的任意两条线，使得它们与x轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。

public class ContainerForRain {

    // 这个题看似代码简单，其实思想比较难。方法是使用双指针，谁小谁结算信息并移动。举例：
    // height=[7, 3, 5, 4, 8, 6]  L=0, R=5   6小，6结算：30，然后R向左移动
    // L=0  R=4  此时7小，7结算：28。虽然以7作为边界能找到的最大值是和末尾的6结合，但是我们不关心某个值能找到的精确最好值，
    // 我们只关心能不能把我们已经找到的值推得更大。最主要的是，以某个值作为边界找到的精确最好值必然是在指针移动前结算过的。
    // 不理解的话可以自己多举几个例子。

    // 比如 [6, 5, 8, 2, 9, 6, 3, 7]   6和7比，6较小，所以结算此时6的答案 8 * 6 == 48  然后L向右移动到5
    // 然后5结算答案  5 * 7 == 35  然后L来到8  此时7比8小，7结算答案  7 * 5 == 35    看到没：7按理说和最左边的6形成的
    // 两个木板能接到最多的雨水，但是我们在结算7时，并没有去寻找当前元素和谁匹配才是最优解，而是直接去算了当前元素能和另一边
    // 的元素能否将答案再次推高。7为什么面对了此时的8？必然是因为L之前有数比7小，才让L移动到了8，那么这个比7小的数，必然已经
    // 和7结算过答案了。

    public static int container(int[] height) {
        if (height == null || height.length < 2)
            return 0;
        int L = 0, R = height.length - 1;
        int res = 0;
        while (L < R) {
            res = Math.max(res, Math.min(height[L], height[R]) * (R - L));
            if (height[L] < height[R])
                L++;
            else
                R--;
        }
        return res;
    }
}
