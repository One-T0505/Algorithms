package GreatOffer.class12;

// leetCode0004
// 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
// 请你找出并返回这两个正序数组的中位数或者上中位数。算法的时间复杂度应该为 O(log (m+n)) 。


public class GetMedianInOrderArr {

    // 该题目要求的时间复杂度为：O(log (m+n))，但是我们可以做到：O(logMin(m, n))   就是利用了下面的两个基本模型
    // 主方法最后看，先去下面学习基本模型。

    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int size = nums1.length + nums2.length;
        boolean even = (size & 1) == 0;
        if (nums1.length != 0 && nums2.length != 0) {
            if (even) {
                return ((double) (getTopK(nums1, nums2, size >> 1) +
                        getTopK(nums1, nums2, (size >> 1) + 1))) / 2.0;
            } else {
                return getTopK(nums1, nums2, size >> 1 | 1);
            }
        } else if (nums1.length != 0) {
            if (even) {
                return (double) (nums1[(size - 1) / 2] + nums1[size / 2]) / 2;
            } else {
                return nums1[size / 2];
            }
        } else if (nums2.length != 0) {
            if (even) {
                return (double) (nums2[(size - 1) / 2] + nums2[size / 2]) / 2;
            } else {
                return nums2[size / 2];
            }
        } else {
            return 0;
        }
    }
    // --------------------------------------------------------------------------------------------------


    // 要完成最后的问题，首先要弄清楚一个子问题。假设给定两个等长的有序数组a1，a2，长度都为k，那么如何快速找出第k小的数，
    // 也就是上中点，最小的数是第一小。最优的方法是用二分。假设a1、a2长度都为4，那就是要找出第4小的数。流程如下，数字仅
    // 代表位置，不代表具体的值.
    // a1 = [1,  2,  3,  4 ]
    //
    // a2 = [1', 2', 3', 4']  一开始二分都来到位置2，判断两个位置值的大小：
    //  1.如果a1[2] == a2[2']，那么直接返回该值，如果相等，那么两个数组一起排完序后，处于3、4位置的就是a1[2]和a2[2']，
    //    就是我们要找的。
    //  2.如果a1[2] > a2[2']，那就来分析下哪些位置的值还有可能是第4小的。那么3、4不可能成为第4小的数，因为前面至少还有
    //    1、1'、2'、2，  3最好的情况就是第5小，还不包括3'、4'。a2中1'、2'不可能成为第4小的数，第4小的数后面还有4个比自己
    //    大的，而1'、2'在自己组里比3'、4'小，在a1组里，比2、3、4小，已经有5个数比自己大了，所以1'、2'不可能。
    //    于是可能的结果就是：a1 = [1, 2]  a2 = [3', 4']，于是就可以递归了，问题就变成了在现在的a1、a2中找出第2小的数，
    //    可以反推当下第2小的数就是在原数组中第4小的数。a1[2] < a2[2']的考虑方式是一样的，也排除掉不可能是第4小的那些元素即可。


    // 上面讲的是长度可以不断二分下去的偶数长度。假如一开始两个数组长度为5，如何处理？流程和上面几乎一样。此时要找出第5小的数。
    // a1 = [1,  2,  3,  4,  5 ]
    // a2 = [1', 2', 3', 4', 5']      一开始二分的位置在3和3'，如果相等直接返回。

    // 1.如果a1[3] > a2[3']，那么3、4、5不可能，1'、2'不可能。所以留下的可能为：
    //   a1 = [1, 2]   a2 = [3', 4', 5']， 这样长度就不相等了，不符合上面的原则，所以此时单独验证下a2[3']是不是大于等于
    //   a1[2],并且小于a1[3]的，如果是直接返回a2[3']，否则就把3'抛弃，那么 a1 = [1, 2]   a2 = [4', 5']，又回到相等长度了。
    //   就可以继续递归下去了。 此时只需要找出a1，a2中第2小的数，此时第2小的数就是原数组中第5小的数，很容易反推。


    // 给定两个有序数组a1，a2，并且a1[l1..r1] 和 a2[l2..r2] 等长    时间复杂度 O(logN)
    public static int getUpMedian(int[] a1, int l1, int r1, int[] a2, int l2, int r2) {
        int m1 = 0, m2 = 0;  // 两个中点指针
        while (l1 < r1) {
            m1 = l1 + ((r1 - l1) >> 1);
            m2 = l2 + ((r2 - l2) >> 1);
            if (a1[m1] == a2[m2])  // 如果相等直接返回
                return a1[m1];
            if (((r1 - l1 + 1) & 1) == 1) {  // 奇数长度
                if (a1[m1] > a2[m2]) {
                    if (a2[m2] >= a1[m1 - 1])
                        return a2[m2];
                    r1 = m1 - 1;
                    l2 = m2 + 1;
                } else { // a1[m1] < a2[m2]
                    if (a1[m1] >= a2[m2 - 1])
                        return a1[m1];
                    r2 = m2 - 1;
                    l1 = m1 + 1;
                }
            } else {  // 偶数长度
                if (a1[m1] > a2[m2]) {
                    r1 = m1;
                    l2 = m2 + 1;
                } else { // a1[m1] < a2[m2]
                    r2 = m2;
                    l1 = m1 + 1;
                }
            }
        }
        // 当从while循环跳出后，此时每个数组都只剩下一个元素，那么第1小的元素就是目标值
        return Math.min(a1[l1], a2[l2]);
    }
    // =====================================================================================================


    // 有了上面这个非常重要的子问题模型后，可以加大难度。假如给定两个不等长的有序数组a1、a2，长度分别为m，n，请找出
    // 第k小的数。该问题会深度使用上面的子问题模型。另g== Math.max(m, n)  l == Math.min(m, n)。就是说g等于较长
    // 的长度，l等于较短的长度。那么k的取值范围只有三种情况：1> 1 <= k <= l  2> l < k <= g  3> g < k <= (l + g)
    // 下面对这三种情况逐一分析。为了便于理解，我们还是举出实际的例子，同样地，数字仅表示位置，不表示值的大小
    //
    // a1 = [1,  2,  3,  4,  5,  6,  7,  8,  9,  10,  11]
    // a2 = [1', 2', 3', 4', 5', 6', 7']
    //
    // 1> 1 <= k <= 7  这种情况下，假如k是5，那就直接在每个数组中取前5个，然后用上面的模型找出这10个中的第5小，就是
    //    全局的第5小
    // 2> 7 < k <= 11 ，假如k==9，那么a1里面的1不可能，因为1即便超过了7'，也只能是第8小；10、11也不可能，因为即便比
    //    a2[1'] 还小，也只能是第10小，第11小。a2中的所有元素都有可能，所以此时a1还剩2～9这8个，a2是7个，无法用模型，
    //    所以单独检查下a1[2]是否>=a2[7'],如果是直接返回a1[2]，如果不是，则直接丢弃该区域，那么长度就变回相等了，又可以
    //    用模型了。
    // 3> 11 < k <= 18  假如 k==15， 那么1～7都不可能，因为1最远的位置就是超过7'，那也只能是第8小，后面的2～7同理；
    //    a2中的1'～3'；也不可能，因为最远的位置，就是1'超过11，那也只能排到第12小，所以1'～3'也不可能。于是，
    //    a1' = [8,  9,  10,  11]   a2' = [4', 5', 6', 7']。此时不能直接用模型，因为模型会求出里面第4小的数，但是
    //    这不是全局第15小的。因为假如r是这8个里第4小的，那么它的前面必然有1～7，1'～3'这10个数，而且这8个里面还有3个
    //    在r的前面，也就是说r是全局的第14小。所以要单独检查下a1'和a2'。如果a1[8] >= a2[7']，直接返回，否则丢弃a1[8]；
    //    再检查a2[4']是否 >= a1[11]，如果是直接返回，否则丢弃a2[4']，如果两次检查都没返回，那么此时
    //    a1' = [9, 10, 11]   a2' = [5', 6', 7']   此时再用模型求出第3小的数就是对的了。

    public static int getTopK(int[] a1, int[] a2, int k) {
        if (a1 == null || a2 == null || k < 1 || k > a1.length + a2.length)
            return Integer.MAX_VALUE;
        // 长短数组重定向
        int[] longer = a1.length >= a2.length ? a1 : a2;
        int[] shorter = longer == a1 ? a2 : a1;
        int l = longer.length;
        int s = shorter.length;
        if (k <= s) { // 1)
            return getUpMedian(shorter, 0, k - 1, longer, 0, k - 1);
        }
        if (k > l) { // 3)
            if (shorter[k - l - 1] >= longer[l - 1]) {
                return shorter[k - l - 1];
            }
            if (longer[k - s - 1] >= shorter[s - 1]) {
                return longer[k - s - 1];
            }
            return getUpMedian(shorter, k - l, s - 1, longer, k - s, l - 1);
        }
        // 2)  s < k <= l
        if (longer[k - s - 1] >= shorter[s - 1]) {
            return longer[k - s - 1];
        }
        return getUpMedian(shorter, 0, s - 1, longer, k - s, k - 1);
        // 这个算法的时间复杂度就是:O(logMin(M, N))
    }
    // ==============================================================================================


    public static void main(String[] args) {
        int[] a1 = {2, 2, 4, 4, 5, 6};
        int[] a2 = {2, 2, 4, 4};
        System.out.println(getTopK(a1, a2, 6));
    }
}
