package GreatOffer.class37;


// 来自字节
// 扑克牌中的红桃J和梅花Q找不到了，为了利用剩下的牌做游戏，小明设计了新的游戏规则
//  1) A,2,3,4....10,J ,Q, K分别对应1到13这些数字，大小王对应0
//  2) 游戏人数为2人，轮流从牌堆里摸牌，每次摸到的牌只有“保留”和“使用”两个选项，且当前轮必须做出选择
//  3) 如果选择“保留”当前牌，那么当前牌的分数加到总分里，并且可以一直持续到游戏结束
//  4) 如果选择“使用”当前牌，那么当前牌的分数*3,加到总分上去，但是只有当前轮、下一轮、下下轮生效，之后轮效果消失。
//  5) 每一轮总分大的人获胜
// 假设小明知道每一轮对手做出选择之后的总分，返回小明在每一轮都赢的情况下，最终的最大分是多少
// 如果小明怎么都无法保证每一轮都赢，返回-1

public class _02_Code {

    // 本题就是纯考验设计递归的能力
    // 因为只有52张牌，所以小明最多能得到26张牌，这里我们简化了输入，cards长度为26，表示的是
    // 每一轮小明会得到的牌；scores长度同样是26，小明开了上帝视角，scores[i]表示第i轮对手的得分
    public static int everyStepWin(int[] cards, int[] scores) {
        return f(cards, scores, 0, 0, 0, 0);
    }


    // cards 和 scores 是固定参数   i表示来到了第几轮
    // 1.hold  0..i-1轮次中，小明对这些牌可做出保留的选择，可做出使用的选择，hold表示之前所有保留的牌的总分
    // 2.cur   0..i-1轮次中，小明做出的所有使用牌的选择，到第i轮了，还可以继续有效果的数是多少
    // 3.next  0..i-1轮次中，小明做出的所有使用牌的选择，到i+1轮了，还能有多少效果维持
    //
    //   假如小明抽到了这些牌：3 2 11 4 7 ? 当前来到了7，? 表示下一轮，3～4是已经做过决定了，假设2和11选择了
    //   保留，3和4选择了使用，那么在当前轮7，hold==13，cur==12，虽然3也使用了，但是效果只有3轮，所以到4的时候，
    //   3的效果就没了；当来到7时，如果选择了保留，那么next==12，因为到i+1轮，4的效果还在。
    private static int f(int[] cards, int[] scores, int i, int hold, int cur, int next) {
        if (i == 25) { // 说明是最后一轮了，那么小明抽到的牌必然会选择使用
            // 之前保留的总分 + 之前对当前轮的增幅 + 当前抽到的牌使用
            int sum = hold + cur + cards[i] * 3;
            if (sum <= scores[i]) // 如果不能赢对手
                return -1;
            return sum;
        }
        // 还没到最后一轮
        // 情况1：选择保留当前抽到的牌
        int score1 = hold + cur + cards[i];
        int p1 = -1;
        // 如果这种选择能保证可以胜利，那才能真的去执行这种情况
        if (score1 > scores[i])
            // 3 2 11 4 7 ? ●  假设现在来到了7，并且3和4选择了使用，2和11选择了保留，那么来到7时，递归
            // 函数就是：f(4, 13, 12, 12) 此时的next是12，表示3～4对?处的影响，如果7选择了保留，
            // 那么调用下一次的递归就是：f(5, 20, 12, 0) 这里调用递归的时候还是在7，现在要填的cur是3～7对
            // ?处的影响，next填的是3～7对●的影响，因为7没使用，所以即便是最近的4使用了，到●处也没效果了，所以
            // next==0
            p1 = f(cards, scores, i + 1, hold + cards[i], next, 0);

        // 情况2：使用当前抽到的牌
        int score2 = hold + cur + cards[i] * 3;
        int p2 = -1;
        if (score2 > scores[i])
            p2 = f(cards, scores, i + 1, hold, next + cards[i] * 3, cards[i] * 3);

        // 如果p1和p2都是-1，说明根本赢不了，返回-1；如果但凡有一个不是-1，就说明有路可走，返回可行的情况
        // 上面的话可以浓缩成下面的一句
        return Math.max(p1, p2);
    }
}
