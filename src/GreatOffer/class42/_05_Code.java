package class42;

// leetCode296 最佳的碰头地点
// 给定一个矩阵，里面全部都是0和1组成。0表示路可以走，1表示当前位置有个人，现在要选一个位置
// 作为碰头地点，让矩阵中所有的1都汇聚于此，哪个地点是让所有走的总路程最少的，返回最少步数。
// 每个人只能上下左右4个方向走。

public class _05_Code {

    // 总流程：先找到让所有的1去哪一行最省，然后再找让所有的1去哪一列最省，汇聚点就是答案
    // 现在要讲一些证明
    // 假如第0行有9个1  最后一行第7行有6个1
    // 现在要尝试找到哪一行是最优的解，需要逐一尝试  先从最后一行第7行尝试
    // 首先第0行的全部到第7行需要：9*7   中间第1行～第6行有多少个1不知道，假设将第1～6行所有的1移动到第7行的步数是x
    // 则将所有的1移动到第7行的总步数是：9*7 + x 1⃣️  第7行本身的1不用移动
    //
    // 假如要把所有的1移动到第6行的话，那么第6行本身的1不用移动，第7行的1移动到第6行是 6*1
    // 第0行移动到第6行的步数是：9*6   第1～5行有多少个1不知道，但是必然比第1～6行的1少，假设第1～5行所有的1移动到
    // 第6行的步数是y，那么将所有的1移动到第6行的总步数是：9*6 + y 2⃣️
    //
    // 两个表达式的第一部分大小显而易见，此外 y < x 因为y包含的1的数量比x包含的少，并且目标位置更近一点，所以 y < x
    // 所以，1⃣️ > 2⃣️  那么第7行就不可能是最优解了。

    //  行序号    当前行1的数量
    //    0           9           总结来说就是，如果某一行1的数量 > 另一行1的数量，那么少的那行就不可能是答案了
    //    1           22          用左图举个例子，0行<5行，那么0行不可能是答案，于是指针向下指向第1行，并将0行的
    //    2           15          1累加到第1行，变成31个1，此时比第5行多，于是第5行不可能是答案了，指向5的指针
    //    3           3           向上移动，并把数量累加，当两个指针重合时就是答案。
    //    4           10
    //    5           12

    // 列的最优解的算法和行的一模一样，只不过是以列为单位来比较


    public static int minDistance(int[][] grid) {
        int N = grid.length;
        int M = grid[0].length;
        int[] rows = new int[N];  // rows[2]表示第2行有多少个1
        int[] cols = new int[M];  // cols[2]表示第2列有多少个1
        // 统计1的数量
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == 1) {
                    rows[i]++;
                    cols[j]++;
                }
            }
        }
        int total = 0;  // 记录总的步数
        int s = 0;   // 起始行
        int pre = 0; // s之前累计了多少个1
        int e = N - 1;  // 终止行
        int post = 0;   // e之后累计了多少个1
        while (s < e) {
            // 小的那个肯定不可能是最优解了，所以第s行和之前累计的1都需要至少移动到s下面的行，所以+1步
            // 这里步数的统计是一次一次统计的
            if (rows[s] + pre <= rows[e] + post) {
                total += rows[s] + pre;
                pre += rows[s++];
            } else {
                total += rows[e] + post;
                post += rows[e--];
            }
        }
        // 此时total已经是将所有的1移动到最优行需要的步数了，下面就要统计到最优列的步数了
        s = 0;   // 第0列
        e = M - 1; // 最后一列
        pre = 0;
        post = 0;
        while (s < e) {
            if (cols[s] + pre <= cols[e] + post) {
                total += pre + cols[s];
                pre += cols[s++];
            } else {
                total += post + cols[e];
                post += cols[e--];
            }
        }

        return total;

    }
}

