package class42;

// leetCode335
// 给你一个正整数数组 distance 。
// 从 X-Y 平面上的点 (0,0) 开始，先向上移动 distance[0] 米，然后向左移动 distance[1] 米，向下移动
// distance[2] 米，向右移动 distance[3] 米，向上移动 distance[4] 米,持续移动。也就是说，每次移动
// 后你的方位会发生逆时针变化。
// 判断你所经过的路径是否相交。如果相交，返回 true ；否则，返回 false 。

public class _07_Code {

    // 数组中的每个元素可以确定一根线，假设来到第i号线，如果它和其他的线有相交，那么只能和0～i-1号线相交，
    // 我们来讨论i号线产生相交的情况。假设第i号线的方向是向下的，这个方向无所谓，可以假设他是任意方向的。
    //  1.i号线不可能和i-1号线相交，因为他们是直角关系。
    //  2.i号线也不可能和i-2号线相交，因为是平行关系。和i-2号线相交唯一的情况就是i-1长度为0，但是数组是正数，所以不可能
    //  3.i号线是可能和i-3号线相交的，但是要满足 d[i-3] >= d[i-1] && d[i] >= d[i-2]
    // 上面三种情况用如下图1来辅助理解。
    //
    //  4.i号线和i-4号线是同向的，他们两个相交的情况就是追尾，如下图2所示，所以要满足：
    //       d[i-1] == d[i-3] && d[i] + d[i-4] >= d[i-2]
    //  5.i号线和i-5号线也可能相交，要满足：d[i-3] >= d[i-1] && d[i-4] <= d[i-2] && d[i] + d[i-4] >= d[i-2]
    //     i-1                        i-1                           i-1
    //   |<-------|                 |<-------|                    |<---------|
    // i |        | i-2           i |        | i-2              i |          | i-2
    //   |  ----->|                          |                               |
    //        i-3                   |i-4     |              i-4 |<----- i-5  |
    //                              |------->|                  |----------->|
    //       图1                       i-3                           i-3
    //
    //  6.i号线也可能和i-6号线相交，只有可能是两个头碰到了一起，要满足：
    //       d[i-5] + d[i-1] == d[i-3] && d[i-4] <= d[i-2] && d[i] + d[i-4] >= d[i-2]
    //    但是，情况6完全可以把它看作i号线和i-5号线在i-5的尾巴碰头，这样就可以把情况6融入情况5
    //                  i-1
    //             |<-------------|
    //           i |              | i-2
    //        i-5  |              |
    //  i-4 |<-----| i-6          |
    //      |      |              |
    //      |-------------------> |
    //                i-3
    //
    // i号线只用向前考虑到i-6就行了，因为再往前比如i-7，已经被i-6，i-5，i-4，i-3完全包围了，如果i和i-7相交，
    // 那必然已经和外部的线相交了，所以不用继续往前考虑了。也就是说i号线只需要向前考虑5条线即可，因为情况5和6可以融合。
    //
    // 此外，在列出的条件中，很明显有些是可以合并的，这些在代码中再简化就行了。

    public static boolean crossing(int[] d) {
        // 如果没有4条线是不可能相交的
        if (d == null || d.length < 4)
            return false;
        // 现在要考虑只有4条线和只有5条线的情况，当有6条线的时候，他前面就有5条线了，就可以循环处理了
        // 也就是说每条线都需要向前考虑5条线，所以从0～4号线要单独考虑，从5号线之后的每条线前面才有5条线
        // 当只有4条线的时候，唯一的可能就是3号和0号相交
        // 当只有5条线的时候，相交的情况有3种：4号和1号相交   或   3号和0号相交   或   0和4追尾
        // 3和0相交和只有4条线的时候判断的条件一模一样，所以可以直接合并，这就是为什么是d.length >= 4
        // 而不是 d.length == 4  因为不想重复判断同一种情况
        if ((d[2] <= d[0] && d[3] >= d[1]) ||
                (d.length >= 5 && ((d[3] <= d[1] && d[4] >= d[2]) || (d[1] == d[3] && d[0] + d[4] >= d[2]))))
            return true;
        // 从5号开始每条线前面都有5条线，并且0～4号这五条线都没有相交
        for (int i = 5; i < d.length; i++) {
            if ((d[i - 3] >= d[i - 1] && d[i] >= d[i - 2]) ||  // 情况3
                    (d[i - 1] == d[i - 3] && d[i - 4] <= d[i - 2] && d[i] + d[i - 4] >= d[i - 2]) ||  // 情况4
                    (d[i - 3] >= d[i - 1] && d[i - 4] <= d[i - 2] && d[i] + d[i - 4] >= d[i - 2]) // 情况5
            )
                return true;
        }
        return false;
    }
}
