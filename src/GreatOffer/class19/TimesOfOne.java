package GreatOffer.class19;

// leetCode233
// 给定一个正数N，比如 N = 13，在纸上把所有数都列出来如下：
// 1 2 3 4 5 6 7 8 9 10 11 12 13
// 可以数出1这个字符出现了6次。给定一个正数N，如果把1~N都列出来，返回1这个字符出现的多少次。

public class TimesOfOne {

    // 思路
    // 对于给定的任意一个正整数num，假如num==1364，我们就将其拆分成两部分：1～364 365～1364
    // 第一部分就是递归，第二部分就是要手动计算的。这样的划分是很讲究的，其道理会在后面讲到。1～364又可以拆分成两部分：
    // 1～64 65～364，不断递归下去。
    // 先手动计算一次365～1364：我们要统计这个范围上的数能贡献多少次1，我们换一种思路来统计：这个范围上的所有数，能
    // 在千位上提供几个1，百位上提供几个1，十位和个位分别能提供几个1。最高位千位上能提供的就是：364 + 1 == 365 个。
    // 百位上能提供几个1：让百位为1，所以十位和个位有10*10种组合，在这100种组合里，千位可以自适应调整为0或1，使得每种
    // 组合都落在365～1364这个范围上。比如：_180，那么千位上只能填1才能使 1180 在 365～1364 之间。
    // 所以百位能提供100个；再看十位上能提供几个1：同样地，让十位固定为1，然后百位和
    // 个位任意组合有100种，并且千位可以自适应调整成0或1使得这些组合能合理范围内。比如：713，那么千位只能是0，才使范围
    // 合理；217，那么千位只能是1，才能使范围合理，总之千位一定能让这100种组合合理，所以十位上也能提供100个1；个位也是
    // 如此。这就是前面说的为什么要这么划分范围，因为好算。综上，答案为：
    // solution(1364) == 最高位上能提供的1(365) + 其他位能提供的1(300) + solution(364)

    // 再看另一个例子，假如num=4523，此时最高位不是1了，情况略有不同。划分范围依然是：1～523 524～4523
    // 此时最高位上能提供的1：1000。其他位置上能提供的1：此时最高位是几就要分成几份，最高位是4，将其分成4份：
    // 524～1523 1524～2523 2524～3523 3524～4523
    // 将百位固定为1，然后十位和个位随意组合，共有100种，而千位可以自适应填0～4，使其必然有4种情况都符合范围，比如
    // 138，那么千位可以是1～4；所以百位可以提供4*100个1；十位也是：假如：715，那么千位可以填0～3，也是4种；
    // 所以其他位每位能提供的1都是100*最高位的值.

    // 这两种情况都了解后，就可以推导通项公式了：假设给定num，我们用 x rest 表示num, 并且num有k位数
    // 其中 x 是最高位的值，rest是剩下几位的值。比如num==6733  那么x==6 rest==733
    // 如果 x == 1 那么最高位能提供的1就是：rest + 1
    // 如果 x != 1 那么最高位能提供的1就是：10^(k-1)
    // 其他位一共能提供的1，最高位不管是否为1都符合这个公式：(k-1) * x * 10^(k-2)
    // 其中 k-1 表示除去最高位还有几位，表示其他位数。其他位的每一位能提供 x * 10^(k-2) 个1
    // 因为固定了其中一位上的值位1，所以剩下的k-2位共有10^(k-2)种组合，每种组合在最高位的自适应下，都能得到x种答案。
    // 当最高位是1，代入x=1，就是第一种情况下的答案。


    public static int solution(int num) {
        if (num < 1)
            return 0;
        int len = lenOfNum(num);
        if (len == 1)
            return 1;
        // tmp的作用就是和num的长度对齐。eg：num==7326，那么tmp==1000
        // tmp = 10^(k-1)
        int tmp = (int) Math.pow(10, len - 1);
        // 提取num最高位数值
        int highest = num / tmp;
        // 最高位能贡献1的次数 如果最高位是1，那么最高位提供1的位数就是：rest + 1。比如：1365  那么
        // 最高位能提供的1就是 365 + 1 == 366。
        // 如果最高位不是1，比如：3367 那么最高位能提供的1就是 1000～1999 这1000个，就是 10^(k-1) 就是 tmp
        int highestOneTimes = highest == 1 ? num % tmp + 1 : tmp;
        // 其余位能贡献1的次数  x * (k-1) * 10^(k-2)  tmp / 10 = 10^(k-2)
        int otherOneTimes = highest * (len - 1) * (tmp / 10);

        return highestOneTimes + otherOneTimes + solution(num % tmp);
    }


    // 给一个正整数num，返回它有几位数
    private static int lenOfNum(int num) {
        int len = 0;
        while (num != 0) {
            len++;
            num /= 10;
        }
        return len;
    }

}
