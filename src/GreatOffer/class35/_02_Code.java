package GreatOffer.class35;

// 小红书
// 魔法师过河，河里有若干石子
// [0,4,7] ： 0表示这里石头没有颜色，如果变红代价是4，如果变蓝代价是7
// [1,X,X] ： 1表示这里石头已经是红，而且不能改颜色，所以后两个数X无意义
// [2,X,X] ： 2表示这里石头已经是蓝，而且不能改颜色，所以后两个数X无意义
// 颜色只可能是0、1、2，代价一定>=0
// 给你一批这样的小数组，要求最后必须所有石头都有颜色，且红色和蓝色一样多，返回最小代价
// 如果怎么都无法做到所有石头都有颜色、且红色和蓝色一样多，返回-1

import java.util.Arrays;

public class _02_Code {


    // 首先需要遍历一遍二维数组，收集一些信息：
    //  1.如果石头数量为奇数 直接返回-1
    //  2.如果红色或蓝色的石头数量超过了一半，直接返回-1
    //  3.确定无色石头如何分配颜色。比如，红色石头有4个，蓝色有8个，那么无色石头需要有6个变成红色，2个变成蓝色

    // 然后，我们先全部把无色石头变成某种颜色，比如红色，那么我们还需要将这变成的红色里挑选两个变成蓝色，挑选
    // 的标准是什么呢？就是选择 变成蓝色的代价比变成红色的代价少最多的两块石头
    // 比如，有4块无色石头：[0, 2, 4]  [0, 6, 3]  [0, 1, 7]  [0, 9, 2]  需要1个变成红色，3个变成蓝色
    // 那就先让他们全变成蓝色，代价为16，再选一块变成红色，选[0, 1, 7]，因为可以让代价减少最多，减少6，所以总代价
    // 为10
    public static int minCost(int[][] stones) {
        int N = stones.length;
        if ((N & 1) == 1)
            return -1;
        // 如果两块石头都是无色的，那就按照 染成红色的代价 - 染成蓝色的代价  递减排序
        // 如果不是两块无色石头，那就按照无色、红色、蓝色排序
        // 排完序后，无色石头都在最前，然后是红色石头，最后是蓝色石头  红色石头和蓝色石头内部是无序的
        // 而无色石头内部，是按照差值递减排序的  换句话说就是：无色石头里，越靠前的石头，是将其从红色变成蓝色最超值
        // 的石头
        Arrays.sort(stones, ((a, b) -> a[0] == 0 && b[0] == 0 ? (b[1] - b[2] - (a[1] - a[2])) :
                a[0] - b[0]));
        int zero = 0;
        int red = 0;
        int blue = 0;
        int cost = 0;
        // 默认先把无色石头全部染成红色
        for (int[] stone : stones) {
            if (stone[0] == 0) {
                zero++;
                cost += stone[1];
            } else if (stone[0] == 1)
                red++;
            else
                blue++;
        }
        // 如果某种颜色石头超过了一半，直接返回
        if (red > (N >> 1) || blue > (N >> 1))
            return -1;
        blue = zero - ((N >> 1) - red);   // 要挑选出几块石头变成蓝色
        // 将排完序的石头里，前blue块石头从红色变成蓝色
        for (int i = 0; i < blue; i++)
            cost -= stones[i][1] - stones[i][2];

        return cost;
    }
}
