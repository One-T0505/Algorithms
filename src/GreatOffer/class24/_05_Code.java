package GreatOffer.class24;


// 给定两个字符串str1和str2，在str1中寻找一个最短子串,
// 能包含str2的所有字符，字符顺序无所谓，str1的这个最短子串也可以包含多余的字符。
// 返回这个最短包含子串。

public class _05_Code {


    // 这个题目要用到滑动窗口，因为str1中子串的长度越大，能搞定str2中字符的数量只会变多，存在着这样一种
    // 单调关系。我们把目标str2换成另一种形式。用一个哈希表来取代str2，key记录的是某种字符，value记录的是
    // 对应的字符在str2中出现的次数。这样str2就被哈希表的形式取代了。
    // 这道题用到的是经典的还款问题，体系学习班里有过类似的题。
    // 假设 s1="bbcabccab..."   s2="bcca" 还需要一个变量all记录一共需要完成几个字符，这里all=4，
    // 因为要完成s2的4个字符。
    //                                                            counter
    //   0 1 2 3 4 5 6 7 8                                         a   1
    //   b b c a b c c a b                                         b   1
    //   L         R                                               c   2     all  4
    //
    //
    // R不断向右扩，0位置发现记录中确实还缺b，于是让b--，并让all--，说明这是一次有效还款
    // 来到1位置，发现记录里b为0，说明已经不需要b了，但是还是让b--，但是all不变，说明这是一次无效还款，还需要还3个
    // 字符；来到2位置，这是一个有效还款；来到3位置，这也是一个有效还款；来到4位置无效还款；来到5位置是一个有效还款，
    // 让c--，并让all--。此时all==0了，说明完成了整个s2，此时记录应该是这样的：(a,0) (b,-2) (c,0) (all,0)
    // 于是此时计算L..R的距离，记录答案；此时说明的是以L为开头
    // 能找到的最短搞定s2的长度；现在让R不动，让L不断右移，看能否缩小这个长度; 先丢弃0位置的b，所以记录中的b++，
    // 但b依然<0，说明此次丢弃的元素并没有破坏整个完成的情况，说明此次缩小长度是可以的，于是记录这个新长度；于是L
    // 继续丢弃1位置的b，b++,b从-1变成了0，也没有影响，因为负数就说明多给了，此时拿回并不影响，再记录新长度；丢弃完
    // 1位置，此时L在2位置，此时要丢弃2位置的c，c++，使得c从0变成了1，本来是不欠的，现在变成了1，那么all++，说明破
    // 坏了情况，使得现在没有s2，所以此时不用再记录答案，这个标志着R在5位置时，L只能缩小到2位置就是极限了，没办法再小
    // 了，此时再换R移动。L、R就是这样一进一退，完成整个循环过程，只遍历一遍s1就完成了。

    public static String minIncluder(String s1, String s2) {
        if (s1 == null || s2 == null || s1.length() < s2.length() || s2.length() == 0)
            return "";
        char[] chs1 = s1.toCharArray();
        char[] chs2 = s2.toCharArray();
        int N = chs1.length;
        int all = chs2.length;
        // 记录s2的字符数量
        int[] counter = new int[26]; // 如果题目没说只包含小写字母，就不能用26的大小
        for (char c : chs2)
            counter[c]++;
        int L = 0;
        int R = 0;
        int minLen = N + 1; // 如果能搞定，一定小于这个数
        int resL = -1;
        int resR = -1;
        while (R < N) {
            counter[chs1[R]]--;
            if (counter[chs1[R]] >= 0) // 有效还款
                all--;
            // 说明此时在现在的L上R已经找到了最近能搞定s2的位置；沿途过程中可能让某些数从正变0，从正变负，
            // 从0变负
            if (all == 0) { // 还完了
                // 小于0有两个原因：1.从0变负  说明这个字符在s2中压根不存在，可以丢弃
                // 2.从正变负  说明还多了，此时拿回也是可以的
                // 当counter[chs1[L]]==0时循环停止，分析为什么counter[chs1[L]]==0，首先一定
                // 不是说这个字符在s2中不存在，因为之前R经过它的时候，必然会减少该字符的在记录中的数量才成为0的，
                // 所以说明之前R经过时这是一个有效还款，所以当L碰到counter[chs1[L]]==0时就不能再丢弃了

                // 并且这里为什么只用判断<0就可以断定是可以丢弃的呢？万一是没出现的字符呢？
                // 这种情况是不存在的，因为L走的路都是R提前走的的，如果沿途上的字符是str1有，而str2没有的，
                // 那么值就会是负数；如果是str1有，str2也有的，那么可能为正、负、0；
                // 不管是什么情况，当跳出while循环后，L处在的位置必然不可能是一个从开始到现在都是0的废字符
                while (counter[chs1[L]] < 0)
                    counter[chs1[L++]]++;
                if (minLen > R - L + 1) {
                    minLen = R - L + 1;
                    resL = L;
                    resR = R;
                }
                // 使其破坏完成情况，然后再让R移动
                all++;
                counter[chs1[L++]]++;
            }
            R++;
        }
        return minLen == N + 1 ? "" : s1.substring(resL, resR + 1);
    }

}
