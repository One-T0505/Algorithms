package GreatOffer.class27;

import java.util.Arrays;

// 企鹅厂每年都会发文化衫，文化衫有很多种，厂庆的时候，企鹅们都需要穿文化衫来拍照.
// 一次采访中，记者随机遇到的企鹅，企鹅会告诉记者还有多少企鹅跟他穿同一种文化衫，
// 我们将这些回答放在 answers 数组里，返回鹅厂中企鹅的最少数量。

public class _04_Code {

    // 首先将数组按递增顺序排序，所有重复值都会被放在一起。这样的话，穿同一种文化衫的企鹅的回答应该是一样的，所以数值相同
    // 的一批是穿相同文化衫的一批企鹅，我们希望能最大程度地自我消化。假如：answers=[2, 2, 3, 3, 3，3，3，3]
    // 0号人说还有其他2个人和自己一样，1号人说也还有其他2个人和自己一样，题目要求的是求出最少的企鹅，也就是说，我们希望
    // 数组中每只企鹅说的其他人都尽量多地从数组内部的企鹅抵消掉。比如最开头的两个2，0号企鹅说的其他2个我们希望包含1号企
    // 鹅，1号企鹅说的其他2个希望包含0号企鹅在内。按理说应该有3个2的，但是数组里只有两个2，因为 2 2 2，刚好可以互相
    // 消化掉，还少了一个2是因为记者没采访到，所以这一批2，能表示最少3只企鹅；下一批有6个3；按理说4个3刚好是一个循环，
    // 3 3 3 3  每只企鹅说的3表示剩余的3个，所以这4个3刚好全部自我消化，最少表示4只企鹅，剩下的两个3独立一组，这2个3
    // 还需要和没采访到的两只企鹅组成一批，所以6个3最少能表示：4 + 4 八只。

    // 这样以来，就可以推导通项公式了：假设一批相同的数C有n个，那么这n个相同的数最少能表示：ceil((n/(C+1)) * (C+1)
    // ceil表示向上取整，如果想求 a/b 向上取整，就是：(a + (b - 1)) / b
    // 化成表达式就是：((n+C)/(C+1))*(C+1)   注意：C+1 不可以抵消！！！！！！！！

    public static int minP(int[] answers) {
        if (answers == null || answers.length == 0)
            return 0;
        Arrays.sort(answers);
        int res = 0;
        int C = answers[0];   // C表示当前数值的字面值
        int n = 1;            // 当前字面值已经收集到了几个
        for (int i = 1; i < answers.length; i++) {
            if (answers[i] == C)
                n++;
            else { // 当第一次碰到和前面字面值不同的元素时，就表明上一批字面值为C的组可以结算了
                res += ((C + n) / (C + 1)) * (C + 1);
                C = answers[i];
                n = 1;
            }
        }
        // 最后一批，也就是到数组结尾的那一批没有下一个不同字面值的元素出现来让最后一批得到结算，
        // 所以跳出循环后需要单独结算最后一批
        res += ((C + n) / (C + 1)) * (C + 1);
        return res;
    }
    // leetCode781
}
