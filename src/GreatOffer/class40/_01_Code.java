package GreatOffer.class40;

import java.util.HashMap;

// 腾讯
// 分裂问题
// 一个数n，可以分裂成一个数组[n/2， n%2， n/2]
// 这个数组中哪个数不是1或者0，就继续分裂下去
// 比如n=5，一开始分裂成[2，1，2]  [2，1，2]这个数组中不是1或者0的数，会继续分裂下去，比如两个2就继续分裂
// [2，1,2]->[1, 0, 1, 1, 1, 0, 1]
// 那么我们说，5最后分裂成[1，0，1, 1, 1, 0，1]
// 每一个数都可以这么分裂，在最终分裂的数组中，假设下标从1开始
// 给定三个数n、l、r,返回n的最终分裂数组里[l, r]范围上有几个1
// n <= 2 ^ 50, n是long类型
// r - l <= 5000, l和r是int类型
// 我们的课加个码:
// n是long类型随意多大都行
// l和r也是1ong类型随意多大都行，但要保证l<=r

public class _01_Code {

    // 当看到题目给的r-l<=5000 就知道不可能把真实的裂变数组写出来然后在l～r上去数1的数量

    // 先完成一个小方法，该递归函数返回n最终的裂变数组的长度
    private static int len(long n) { // 时间复杂度为O(logN)
        if (n == 0 || n == 1)  // 如果n等于0或1 那么裂变数组的长度为1  只有自己
            return 1;
        return (len(n >> 1) << 1) | 1;
    }
    // 让n==100，从0～100都输出一下len，会发现规律：
    // 如果n==0，那么结果为1，这个是特例；其他所有情况下，
    // 如果 2^i <= n <= 2^(i + 1) - 1  那么n最终裂变的数组长度为 2^(i + 1) - 1
    // 比如 ：  2^3 <= 11 <= 2^4 - 1  所以len(11) == 2^4 - 1 == 15
    // 所以可以将该方法优化成时间复杂度为O(1)的方法


    // 了解规律后的方法  好像复杂度差不多
    private static int len2(long n) {
        if (n == 0)
            return 1;
        int L = 1;
        int R = 1;
        while (!(n >= L && n <= R)) {
            L <<= 1;
            R = (L << 1) - 1;
        }
        return R;
    }
    // ==============================================================================================


    // 完成了上面的小任务后，继续分析：我们得到了一个数n最终的裂变数组的长度，那么题目给出的l、r我们就可以划分区间了
    // 如果r<=len(n/2) 那么l～r只和裂变数组的第一部分有关；如果l>len(n/2) + 1  那么l～r只和裂变数组的第三部分有关
    // 所以我们可以对l～r二分，将他们分摊在不同的部分上
    // 并且第一部分和第三部分的长度和每个元素都是对应相等的，因为都是n/2裂变的结果

    // 主方法  默认l、r是有效范围，在n的裂变数组长度范围内
    public static long burst(long n, long l, long r) {
        // base case  n==1 || n==0 其裂变数组的长度都是1，并且因为题目给的l、r必然是合理的，所以一定是在n
        // 的裂变数组长度下的合理范围 所以 n为0或1时，l==r==1，不可能是别的，所以正确的base case应该以n的
        // 情况来定
        // 我一开始写的时候使用l==r作为base case的条件的，即便l==r了，也不代表是循环可以结束的标志了，因为
        // n此时完全可以是>1的数，还没到循环结束
        if (n == 1 || n == 0)
            return n;
        long len = len(n >> 1); // n裂变数组第一部分的长度
        // 是否包含中间部分的1，在这之前还要判断中间那部分是否为1
        // (l > len + 1 || r <= len) 两个条件中一个就说明，查询的区间和中间那部分彻底无关，所以mid==0，
        // 表示中间那部分我只能包含0个1；如果l、r涵盖了中间那个位置，就需要先对中间部分是否为1检查下，
        // 如果为1，那就可以包含1个1，否则只能包含0个1
        long mid = ((l > len + 1 || r <= len) ? 0 : n % 2);

        // 现在来算第一部分能包含几个1
        // 如果l>len，说明l已经超过了第一部分，那么整个l～r就和第一部分彻底无关
        // l<=len，就说明l～r区间是和第一部分有重合的，就递归调用n/2，但是右边界需要考虑大小：r超过了第一部分的
        // 长度的话，那就取len，否则就取r
        long left = l > len ? 0 : burst(n >> 1, l, Math.min(r, len));

        // 现在来算第三部分包含了几个1  比如一个n的裂变数组长度是201，那么三个部分的长度分别为：[100, 1, 100]
        // 假设给的l、r是[87, 122] 左边和中间已经算过了，现在只需要用l、r算在第三部分包含了几个1
        // len+2就是第三部分开始的位置，我们要把l、r变成只在第三部分上的范围，所以需要决策Math.max(len + 2, l)
        // 经过变换后就变成了：[102, 122]   如果给的是[107, 122] --> [107, 122]
        // 经过变换后，还需要进行下标变换，我们要在第三部分上的[102,122]上找有多少个1，其实就是在
        // n/2的裂变数组的[1, 21]上找有几个1，因为第一部分和第二部分一样，减去的部分就是第一喝第二部分的长度
        long right = r <= len + 1 ? 0 : burst(n >> 1, Math.max(len + 2, l) - (len + 1),
                r - (len + 1));
        return left + mid + right;
    }
    // 根据master公式可以讲burst方法写成如下形式：T(n) = 2T(n/2) + O(logN)
    // 所以时间复杂度为O(N)
    // ==========================================================================================





    // 下面是更优的解法 时间复杂度为O(logN) 要用到线段树的思想
    // 常规的线段树是一棵二叉树，每个结点的左右孩子分别二分当前结点代表的区间
    // 现在我们可以把线段树拓展成一棵三叉树，如果当前结点表示的区间是：[1,n] 那么就可以组织成如下的形式：
    //
    //             [1,n]                                                  31
    //       /       |       \                                        /    |   \
    // [1,n/2]  [n/2+1,n/2+1] [n/2+2,n]                             15     1    15
    //                                                            / | \         / | \
    //                                                           7  1  7       7  1  7
    //                                                         / |\  / |\     /|\   /|\
    //                                                        3  1 3 3 1 3   3 1 3 3 1 3
    // 3底下应该还接着分的，但石花不下了，所以没画
    // 给给定的n构造一棵这样的树，每个结点表示其长度，然后用哈希表存储对应长度下，数组全体包含1的个数。
    // 然后l、r就可以不断向下分给某个区间，如果l、r全包了某个区间，那就在哈希表中返回值；没全包的情况下，
    // 就继续向下转发，虽说每个结点有三个分叉，实际上第1个孩子和第3个孩子一模一样，走哪都一样，而中间的分叉
    // 只需要常数时间就可以完成，所以从顶点出发，也就是向左走了一个树高，向右走了一个树高，所以时间复杂度为：
    // O(2logN)-->O(logN)

    public static long burst2(long n, long l, long r) {
        // key: 某个数n   value: 对应的裂变数组全体中有多少个1
        HashMap<Long, Long> one = new HashMap<>();
        fillOne(n, one);
        return f(n, l, r, one);
    }


    // 运行该方法可以一次性把：n  n/2  n/4  n/8 ... 1 这些数的裂变数组长度填入到len表中
    // 并返回n的裂变数组的长度
    private static long fillLen(long n, HashMap<Long, Long> len) {
        if (n == 0 || n == 1) {
            len.put(n, 1L);
            return 1;
        }
        long half = fillLen(n >> 1, len);
        long res = half << 1 | 1;
        len.put(n, res);
        return res;
    }


    // 运行该方法可以一次性把：n  n/2  n/4  n/8 ... 1 这些数的裂变数组有多少个1填入到one表中
    // 并返回n的裂变数组中有多少个1
    private static long fillOne(long n, HashMap<Long, Long> one) {
        if (n == 1 || n == 0) {
            one.put(n, n);
            return n;
        }
        long half = fillOne(n >> 1, one);
        // half << 1 就表示第一部分和第三部分一共有多少个1  中间部分有几个1就是：n % 2
        long res = (half << 1) + n % 2;
        one.put(n, res);
        return res;
    }


    // 最核心的方法  该方法返回n的裂变数组中从l～r上有多少个1
    // 虽然下面左图的表现方式是自然的，但是因为第一部分和第三部分一样，所以我们会将其也转换为如下右图
    //        [1,31]                             [1,31]
    //    /     |    \          -->           /    |    \
    // [1,15]  [16] [17,31]                [1,15] [16]  [1,15]
    // 也就是说整棵树每个结点的左右孩子的左边界都是1
    private static long f(long n, long l, long r, HashMap<Long, Long> one) {
        if (n == 1 || n == 0)
            return n;
        long half = len(n >> 1);
        long all = half << 1 | 1;
        long mid = n & 1; // 如果n是奇数 ，那么中间部分的值就为1
        // 整棵树每个结点的左右孩子的左边界都是1 而l不可能<1 所以用下面的方式表达全包，这和正常线段树有点不同
        if (l == 1 && r >= all) {
            if (one.containsKey(n))
                return one.get(n);
            else {
                long pre = f(n >> 1, 1, half, one);
                long res = pre << 1 | mid;  // 第一部分包含几个1，第三部分就是一样的
                one.put(n, res);
                return res;
            }
        } else { // 没有全包
            mid = (l > half + 1 || r < half + 1) ? 0 : mid;
            long left = l > half ? 0 : f(n >> 1, l, Math.min(half, r), one);
            long right = r < half + 2 ? 0 :
                    f(n >> 1, Math.max(l - half - 1, 1), r - half - 1, one);

            return left + mid + right;
        }
    }


}
