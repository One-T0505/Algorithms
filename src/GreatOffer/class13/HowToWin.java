package class13;


// 谷歌面试题扩展版
// 面值为1~N的牌组成一组，每次你从组里等概率的抽出1~N中的一张，下次抽会换一个新的组，有无限组。
// 当累加和<a时，你将一直抽牌；当累加和>=a且<b时，你将获胜；当累加和>=b时，你将失败。
// 返回获胜的概率，给定的参数为N，a, b

public class HowToWin {

    public static double winV1(int N, int a, int b) {
        if (N < 1 || a < 0 || b < 0 || a >= b)
            return 0.0;
        if (b - a >= N)
            return 1.0;
        return f(N, a, b, 0);
    }


    // N, a, b是固定参数，sum表示已经抽到的累加和
    // 该方法返回在N、a、b这样的规则下，已经凑出sum了之后的获胜概率
    private static double f(int N, int a, int b, int sum) {
        if (sum >= a && sum < b)
            return 1.0;
        if (sum >= b)
            return 0.0;
        double w = 0.0;
        for (int i = 1; i <= N; i++)
            w += f(N, a, b, sum + i);
        return w / N;
    }
    // =============================================================================================


    // 发现计算每个值的时候有枚举行为，所以很自然地想到了斜率优化。因为上面的递归参数虽然多，但是实际上就一个
    // 可变参数sum。假如N=4，我们计算f(4)的结果是这样计算的：(f(5) + f(6) + f(7) + f(8))/4
    // 计算f(5)的结果是这样计算的：(f(6) + f(7) + f(8) + f(9))/4    很明显是有重复计算的。
    // 所以，f(4) = (4f(5) + f(5) - f(9))/4  --> f(4) = (5f(5) - f(9))/4，这样就通过了有限的依赖
    // 替代了枚举行为。所以通项公式可以提炼为：f(i) = ((N + 1)f(i + 1) - f(N + i + 1))/N
    // 但是这个公式不适合所有的i。
    //
    // 假设a=14，b=17，N=5，也就是说14～16赢，>=17输。来看a前一个位置13，实际上13的获胜概率为：0.6，但是根据通项公式，
    // f(13) = (6*f(14) - f(19))/5 == 6/5，答案错误。所以a-1这个位置需要单独计算，公式为：f(a-1)=(b-a)/N
    // 再看a-2位置12，根据公式应该是：f(12) = (6*f(13) - f(18))/5 == 0.72，是对的，因为根据自然智慧，
    // f(12) = (f(13) + f(14) + f(15) + f(16) + f(17))/5 == 0.72. 为什么公式也符合？因为f(18)==0，减不减都行。
    // 再看11位置，因为可能的结果只有12～16，都不在输的范围里。所以
    // f(11) = (f(12) + f(13) + f(14) + f(15) + f(16))/5 ==> f(11) = (N + 1)f(12)
    // 所以，综合来看，a-1位置需要单独公式，b-N-1～b-2这N个数的公式为：f(i) = (N + 1)f(i + 1)/N，只有更往前的位置
    // 才有：f(i) = ((N + 1)f(i + 1) - f(N + i + 1))/N     才需要补上最后减法的这个修正项。
    private static double g(int N, int a, int b, int sum) {
        if (sum >= a && sum < b)
            return 1.0;
        if (sum >= b)
            return 0.0;
        if (sum == a - 1)
            return (b - a) * 1.0 / N;
        double res = (N + 1) * g(N, a, b, sum + 1);
        if (sum + N + 1 < b)
            res -= g(N, a, b, sum + N + 1);
        return res / N;
    }
    // ===============================================================================================


    // 动态规划
    public static double winV2(int N, int a, int b) {
        if (N < 1 || a < 0 || b < 0 || a >= b)
            return 0.0;
        if (b - a >= N)
            return 1.0;
        double[] dp = new double[b + 1];
        for (int i = a; i < b; i++)
            dp[i] = 1.0;
        dp[a - 1] = (b - a) * 1.0 / N;
        for (int i = a - 2; i >= 0; i--) {
            double res = (N + 1) * dp[i + 1];
            if (i + N + 1 < b)
                res -= dp[i + N + 1];
            dp[i] = res / N;
        }
        return dp[0];
    }
    // 这个题目给我们的启发：当我们最开始去尝试递归时，应该找一些最普通的位置，或者说是离边界远一点的地方，去寻找
    // 最通用的算法，然后再回去边界附近尝试看是否有特殊之处。
    // --------------------------------------------------------------------------------------------------

}
