package GreatOffer.TopHotQ;


// 给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务
// 可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一
// 个任务，或者处于待命状态。然而，两个相同种类的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续
// n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
// 你需要计算完成所有任务所需要的最短时间。

// 1 <= task.length <= 10^4
// tasks[i] 是大写英文字母
// n 的取值范围为 [0, 100]

public class _0621_TaskScheduler {

    // 这个题目的思路有点难。我们首先要把每种任务的词频统计出来，然后找出最大的词频数maxCount，再找出所有
    // 出现了maxCount次的任务种类，也就是说不仅要找出最大词频数，还要找出哪几种任务出现了最多词频数。

    // 我们先看一个最大词频数只有一种任务的情况。当统计完所有任务的词频后，原始数组就没用了。
    // (a, 4)  (b, 3) (c, 3) (d, 2)  k==3     最大词频数4，只有a这一种任务。我们先把 a 排好，排成如下的形式：
    //
    // a _ _ _ a _ _ _ a _ _ _ a       因为k==3，所以每个 a 之间至少得隔三个空位。接下来就是按词频从高到低
    //
    // 来填空格。首先来填 b 任务，就顺着填，填成这样： a b _ _ a b _ _ a b _ _ a
    // 再来填 c ：a b c _ a b c _ a b c _ a
    // 再来填 d ：a b c d a b c d a b c _ a     注意，当空格还有剩余的话，也不能移除，因为这是 a 任务的底线，
    //
    // 所以，如果有空格剩余，依然保持原有的时间长度。


    // 再来看第二种情况。(a, 4)  (b, 3) (c, 3) (d, 2)  k==2
    // 依然是根据最大词频任务来确定初始空格长度，根据 a 的词频4 和时间间隔2，确定了如下的空格：
    //
    // a _ _ a _ _ a _ _ a         依然是按顺序填   a b c a b c a b c a
    //
    // 当我们填完 c 任务后，空格全部被占满了，并且还有任务没填完，这应该如何处理？想想我们最开始根据最多任务来确定
    // 空格图时，那些空格只是下限，少于这个不行，所以中间只要间隔 >=k 即可。
    // 于是，碰到空格填满的情况，我们只需要把剩余任务 依次填写每一轮的后面即可。
    //
    // a b c d a b c d a b c a    所以，当空格填满的时候，最终调度的时长就是初始空格长度 + 剩余任务数量


    // 再看第三种情况，就是最大词频数的任务不止一种。 (a, 5)  (b, 5) (c, 5) (d, 4) (e, 2)  k==4
    // 这种情况下，就把所有最高频的任务看作一个整体去设计空格图，构成如下的初始空格图：
    //
    // a b c _ _ a b c _ _ a b c _ _ a b c _ _ a b c    这样就保证了每两个a，每两个b，每两个c之间都符合要求
    //
    // 本来两个 a 之间要有 4 个空格，但是多了 b c 所以只剩两个空格了，剩下的原则就和上面的一样了。

    public int leastInterval(char[] tasks, int n) {
        int[] counter = new int[26];
        int N = tasks.length;
        int maxCount = 0;
        for (char c : tasks){
            counter[c - 'A']++;
            maxCount = Math.max(maxCount, counter[c - 'A']);
        }
        int maxKinds = 0;
        for (int i = 0; i < 26; i++) {
            if (counter[i] == maxCount)
                maxKinds++;
        }
        // 上面的就是在统计同大词频数和出现最大词频数的任务种类
        // 接下来就是计算
        // 这个变量是啥意思？  拿这个举例子 a b c _ _ a b c _ _ a b c _ _ a b c _ _ | a b c
        // 上面举例的三种情况，结尾处就是最大词频任务，这个是肯定的，所以还没确定的就是 | 之前的任务数量
        int tasksExceptFinal = N - maxKinds;
        // 我们把上面一行的图想象成这样：_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ | a b c
        // 就是除了最后的确定的任务，其余的位置暂且都是空的
        int spaces = (n + 1) * (maxCount - 1);  // 这个就是统计有多少个空格的
        // 这个就是统计还会剩下多少个空格
        // 好好品下面这两行代码，这就包含了所有的情况，空格填满的情况，填不满的情况
        int restSpaces = Math.max(0, spaces - tasksExceptFinal);
        return N + restSpaces;
    }
}
