package class16;

// leetCode 剑指Offer62 圆圈中最后剩下的数字
// 约瑟夫环问题
// 给定一个链表头节点head和一个正数m。从头开始，每次数到m就杀死当前节点，然后被杀节点的下一个
// 节点从1开始重新数，周而复始直到只剩一个节点，返回最后的节点。该链表是环。默认第一个结点从编号1开始。

public class JosephusProblem {

    // 首先要解决第一个问题：报数与编号的通项公式。假如只有如下4个结点，其编号如下所示，请问报数为13时，编号为几？
    //
    //    1 --> 2                  编号为1。假设报数为x，结点共有i个，则对应编号 y == x % i.
    //    ↑     ↓                  但是该公式中，x==0时，推出y==0，这不是我们希望看到的，所以需要对该公式变形：
    //    4 <-- 3                  y == (x - 1) % i + 1  这样就完全对了。变形的思路可以画画图分析下函数图像即可。
    //
    // 接下来还需要完成一个方法，那就是根据杀死一个结点后的报数去推导在杀死该结点前的报数。举个例子，一开始有7个结点，报
    // 数为3的结点杀死。
    // 初始     编号  1  2  3  4  5  6  7
    // 杀死     编号  5  6  ❌ 1  2  3  4
    // 杀死     编号  2  3  ❌ 4  5  ❌ 1
    // 杀死     编号  4  ❌ ❌  1  2  ❌ 3
    // 杀死     编号  1  ❌ ❌  2  3  ❌ ❌
    // 杀死     编号  1  ❌ ❌  2  ❌  ❌ ❌        这里只剩两个结点了，但是规定报数到3就杀死，所以结点1要杀死，因为
    // 杀死     编号  1  ❌ ❌  2  ❌  ❌ ❌        循环回来了
    // 杀死     编号  ❌  ❌ ❌  1  ❌  ❌ ❌
    // 返回初始循环链表的第4个结点。
    // 假设我们完成了一个方法f，传入一个报数，返回杀死一个结点前该报数对应的报数。例如传入第3行的4，f函数应该返回1，因为
    // 在杀死当前轮次的结点前，4对应的是1这个编号。假设当前轮次杀死的编号为s，可以自己画下函数图像，横坐标是杀死后的编号，
    // 纵坐标为杀死前的编号。
    //
    //      |
    //  i   |               ●
    // ...  |
    // s+2  |        ●
    // s+1  |    ●
    // s    |
    //      |
    // s-1  |                                  ●
    // ...  |
    // 1    |                        ●
    //      |____|____|____|____|____|_________|______
    //           1    2  ...   i-s  i-s+1 ... i-1
    //
    //  这图像延长之后会发现是个周期函数，我们只需要限制其定义域即可。这个函数图像和上面的公式一样，不过需要做些平移转换
    //  这个图像和 y == (x - 1) % i + 1 1⃣️ 如出一辙，可以把该图像看作是1⃣️向上平移s个单位，所以新公式可以写作：
    //  新编号 == (旧编号 - 1 + s) % i + 1  2⃣️
    //
    // s 是什么呀？ s是长度为i的循环链表中报数为m的编号，所以 s == (m - 1) % i + 1，将 s 代入2⃣️，得到：
    // 新编号 == (旧编号 + (m - 1) % i) % i + 1  3⃣️⃣️
    // 有了这个3⃣️就彻底解决问题了。试想下，最后一定只剩下一个结点，其编号一定是1，所以我们需要倒退还剩2个结点时，其编号
    // 为多少？ 根据3⃣️，旧编号==1，m==3，因为我们想知道还剩两个结点时的新编号，所以代入i==2，于是得到：新编号==2，
    // 根据表格，结果正确，于是我们可以继续向上迭代，直到i==7时。


    // n个结点，编号从1～n，数到m就杀死结点，返回最终存活的结点
    public static int survival(int n, int m) {
        if (n == 1)
            return 1;
        return (survival(n - 1, m) + (m - 1) % n) % n + 1;
    }


    // 该问题可以变形：
    // 第一轮杀死数到5的，第二轮杀死数到6的，第三轮杀死数到8的，返回最后一个存活的人最开始的编号
    // 虽然问题变了，但是公式还是3⃣️，只不过每轮需要改变参数m而已。

}
