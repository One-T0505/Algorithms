package class10;

// leetCode629
// 给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。
// 逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。
// 由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。
// 参数n，其实含义就是1～n的全排列中选择符合要求的数组。每一种排列就是一个数组

public class InversePairs {


    // 动态规划。定义一张n*k的二维表cache。 行数从1～n，列数从0～k。cache[i][j]表示用1～i的数全排列，有j个逆序对的排列
    // 方式有多少种。下面图中❌表示没用的空间，并且边界情况已经填好了，因为很容易分析出。我们现在要分析一般位置.
    //
    //         0   1   2   3   4   5   6
    //      0  ❌  ❌  ❌   ❌  ❌   ❌  ❌                   假设n=6，k=6，现在有个一般位置[5,3]，它的值应该随多少呢？
    //      1  1   0   0   0   0   0   0                    c[4][3]表示用1～4全排列中3个逆序对的排列有多少种方式，
    //      2  1                                            如果在c[4][3]的每一种排列方式下，只将5放在最后，那么不
    //      3  1                                            会影响总的逆序对数，因为5是最大的，并且在最后；所以c[4][3]
    //      4  1                                            就是c[5][3]答案的一部分。同样的，c[4][2]对应的每种排列下，
    //      5  1           ？                               把5添加在倒数第2位，这样就能提供刚好一个新的逆序对，这样
    //      6  1                                            c[4][2]每种排列下就能新加一个逆序对到3，所以，c[4][2]也是
    //                                                      c[5][3]答案的一部分。c[4][1]也是，c[4][0]也是。所以：
    //  c[5][3] = c[4][3] + c[4][2] + c[4][1] + c[4][0]
    //  c[5][4] = c[4][4] + c[4][3] + c[4][2] + c[4][1] + c[4][0]
    //  是不是很容易想到斜率优化？   c[5][4] = c[5][3] + c[4][4]    本来是枚举行为，现在压缩成了常量时间
    //
    //  这种情况只适合于c[i][j]，j<i的情况。比如我们要填c[4][4]呢？
    //  c[4][4] = c[3][4] + c[3][3] + c[3][2] + c[3][1].   因为c[3]表示只用3个数，所以我们插入的位置只有4个，
    //  所以只能是4个元素的累加和。
    //  c[4][5] = c[3][5] + c[3][4] + c[3][3] + c[3][2].   因为我把4插在最前面也只能新增3个逆序对，所以最少用3个数
    //  要搞定2个逆序对。
    //  c[4][6] = c[3][6] + c[3][5] + c[3][4] + c[3][3]
    //  j>=i的情况下，也可以用斜率优化。 这些计算都可以提取出通用公式。
    //  c[4][5] = c[4][4] + c[3][5] - c[3][1]
    //  c[4][6] = c[4][5] + c[3][6] - c[3][2]
    // 所以整个二维表又被我们分成了两个区域，左下区域，对角线和右上区域。

    public static int dp(int n, int k) {
        if (n < 1 || k < 0)  // 无效参数
            return -1;
        int[][] cache = new int[n + 1][k + 1]; // cache[0]这一行无用
        // cache[1]这一行，除了cache[1][0]=1，其余都是0
        cache[1][0] = 1;
        // 单独处理第0列
        for (int i = 1; i <= n; i++)
            cache[i][0] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
//                if (i > j)
//                    cache[i][j] = cache[i - 1][j] + cache[i][j - 1];
//                else
//                    cache[i][j] = cache[i][j - 1] + cache[i - 1][j] - cache[i - 1][j - i];

                // 上面的4行写法是标准写法，但是我们发现不管怎样都有cache[i - 1][j] + cache[i][j - 1]这两项，
                // 所以可以更精简
                if (j > (i * (i - 1)) >> 1) // i个数最多能搞定 i(i-1)/2 个逆序对 超过了就直接停止
                    break;
                cache[i][j] = cache[i - 1][j] + cache[i][j - 1];
                if (i <= j)
                    cache[i][j] -= cache[i - 1][j - i];
            }
        }
        return cache[n][k];
    }
    // 上面的写法在算法上来说已经完全没问题了，但是该题目要求的返回值有点要求，所以需要针对性的修改。于是有了下面的版本


    public static int dpV2(int n, int k) {
        if (n < 1 || k < 0)  // 无效参数
            return -1;
        int radix = 1000000007;
        int[][] cache = new int[n + 1][k + 1]; // cache[0]这一行无用
        cache[1][0] = 1;
        for (int i = 1; i <= n; i++)
            cache[i][0] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                // 每一个单元格都算取模操作
                cache[i][j] = (cache[i - 1][j] + cache[i][j - 1]) % radix;
                if (i <= j)
                    // 这里就有问题了，我们依赖的其他格子已经是取模后的结果了，不是真实值了，无法用真实值来表示
                    // 比如模完之后一个是3，一个是5，有可能3的真实值比5的真实值大。所以可能出现负数的情况。所以
                    // 需要这样特殊的处理
                    cache[i][j] = (cache[i][j] + radix - cache[i - 1][j - i]) % radix;
            }
        }
        return cache[n][k];
    }
}
