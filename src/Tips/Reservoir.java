package Tips;
// 蓄水池算法
// 假设有一个源源不断按顺序吐出不同球的机器,从1号开始吐，只有装下10个球的袋子，
// 每一个吐出的球，要么放入袋子，要么永远扔掉，再也不找回。如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里。
// 这个问题在工程上很有意义。

// 实现思路：
// 前10个球必入袋。10号之后的第i号球入袋的概率为 10/i，因为袋子中有10的容量
// eg：12号球入袋的概率为10/12.当袋子没满时，球入袋不用替换别的球；当袋子满的时候，有新的球要入袋时，就需要从袋中10个球中随机
// 挑一个丢弃，每个球被挑到的概率相等。

// 举例：当吐出17号球之后，所有的球入袋的概率都是相等的 10/17   当吐出41号球之后，所有的球入袋的概率都是相等的 10/41
// 证明：当吐出17号球之后，3号球还在袋中的概率是多少？
//      当3号被吐出时必入袋，并且在11号到来之前都必然在袋子里，所以当前概率为1；
//      10/11 * 1/10 = 1/11 表示11号刚好入袋，并且3号刚好被选中替换的概率,所以就是
//      11号来到时，3号死亡概率，那么 1 - 1/11 = 10/11 就是11号吐出后，3号还存活在袋子中的概率。
//      那么12号吐出后，3号还存活在袋子中的概率为： 10/11 * (1 - 10/12 * 1/10) = 10/12
//      ....
//      那么17号吐出后，3号还存活在袋子中的概率为：10/17    其他的1，2。。9号球在17号吐出后，还存活在袋子中的概率都为10/17
//
//     17号吐出后，11号球还存活在袋子中的概率为：10/11 * (1 - 10/12 * 1/10) * (1 - 10/13 * 1/10)... = 10/17
//
// 这样就实现了，不管吐出多少个球，所有的球在袋子中的概率都相等。

public class Reservoir {

    // 该函数用代码的形式来模拟下实验. end表示吐出多少号球后结束，并统计这所有end个球的情况.从1开始
    public static void test(int testTime, int capacity, int end){
        int[] counter = new int[end + 1];  // 统计
        for (int time = 0; time < testTime; time++) {
            int[] bag = new int[capacity];
            for (int i = 1; i <= end; i++) {
                if (i <= capacity)  // 前10个球直接入袋
                    bag[i - 1] = i;
                else {
                    int des = (int) (Math.random() * i) + 1;; // 等概率返回1～i之间的某个数
                    if (des <= capacity){  // 决定入袋
                        int sacrifice = (int) (Math.random() * capacity);
                        bag[sacrifice] = i;
                    }
                }
            }
            // 每次测试完就统计一下，最后袋子中存活的是哪几个球；当测试次数越来越多，这个统计的数组里每个元素的值应趋于相等
            for (int num : bag)
                counter[num]++;
        }
        // 打印统计数组
        for (int num : counter)
            System.out.println(num);
    }
    // 这样的工程意义在哪呢？ 有没有发现这样的蓄水池不管进行到何时，都可以实时保证所有元素入袋的概率都相同。
    // 想象一个游戏有一个抽奖活动。比如：今晚7点到明晚7点之间登录游戏的用户可参与抽奖，名额为100位，并于明晚7点公布中奖名单。
    // 如果用传统方法，就得等到明晚7点以后，将所有服务器中的数据汇总，然后随机抽取100名获奖用户，这样做的实时性很不好，并且
    // 如果游戏的规模很大，服务器遍布各个国家，那么将所有数据汇总就很复杂。
    // 如果用蓄水池的方法，这里的球就相等于在规定时间内登陆的用户，此时球袋的容量为100，前100名登陆的用户直接进入奖池，
    // 之后登陆的用户跟这些球一样以 100/i 的概率入选奖池，并从奖池中随机挑选一个用户置换，到明晚7点的时候只需要把
    // 现在奖池中的用户公布即可。用蓄水池的方法就可以实时不断地更新奖池，并且做到等概率的公平。


    public static void main(String[] args) {
        test(1000000, 10, 34);
    }

}
